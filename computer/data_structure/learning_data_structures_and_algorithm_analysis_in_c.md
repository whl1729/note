# 《Data Structures and Algorithm Analysis in C》学习笔记

## 数学证明方法

1. 数学归纳法
2. 反证法

## 递归的基本规则

1. 基准情形。必须存在不需递归就能解决的基准情形。
2. 不断推进。递归调用必须朝着基准情形的方向不断推进。
3. 设计法则。假设所有的递归调用都能生效。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

## 算法分析

### 增长率描述
大O记数法

### 最大子数组问题
书中给出了最大子数组问题的四种解法，时间复杂度分别是O(N^3), O(N^2), O(NlogN)和O(N)。

* O(N^3)解法。穷尽法。用下标组合(i, j)来表示第i到j个元素组成的子数组，遍历所有的子数组(i,j)，并计算出其元素之和，对比得最大值。
* O(N^2)解法。思路仍然是穷尽法。但对O(N^3)解法进行优化。O(N^3)解法包含太多重复性的工作，比如在计算子数组元素之和时，计算(i, j+1)时会重新计算一遍(i, j)，O(N^2)算法相当于把(i, j)的计算结果记录下来，计算(i, j+1)时就可以使用这个现成的计算结果。
* O(NlogN)解法。分治法。这种解法的思路时把大问题分解成两个相对小一些的问题，分别计算两个小问题的结果，然后汇总得到大问题的答案。把大数组均分成两个小数组，那么最大子数组必然位于左边、右边或中间这三个位置之一。
* O(N)解法。O(N)解法抓住了问题的本质：最大子数组从首元素到任意一个元素之间的总和永远大于0。根据这个性质，O(N)解法只需从左到右扫描一遍数组，扫描时，先假设当前扫描元素就是最大子数组的元素，并即时计算当前数组元素之和。等到计算结果不大于0后，可以舍弃当前子数组，从下一个元素开始重复统计。O(N)解法比O(NlogN)解法的差异之一是前者更抓住了问题的本质。


