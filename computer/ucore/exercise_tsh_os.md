# 《Tsinghua os mooc exercise》笔记

## 第三讲 启动、中断、异常和系统调用

1. 下列选项中，不可能在用户态发生的是（ ）
- [ ] 系统调用 
- [ ] 外部中断 
- [x] 进程切换
- [ ] 缺页

> 疑问：外部中断、缺页可以在用户态发生吗？比如用户态下读取用户输入时，键盘有输入后产生中断？再比如用户态下读取文件内容，发生缺页？但这两种情况最终还是要经过内核态来处理吧？答案解析：系统调用是提供给应用程序使用的，由用户态发出，进入内核态执行。外部中断随时可能发生；应用程序执行时可能发生缺页；进程切换完全由内核来控制。

2. 中断处理和子程序调用都需要压栈以保护现场。中断处理一定会保存而子程序调用不需要保存其内容的是（ ）
- [ ] 程序计数器 
- [x] 程序状态字寄存器 
- [ ] 通用数据寄存器 
- [ ] 通用地址寄存器

> 答案解析：程序状态字（PSW）寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。

3. 中断向量地址是（ ）
- [ ] 子程序入口地址 
- [ ] 中断服务例程入口地址 
- [x] 中断服务例程入口地址的地址 
- [ ] 例行程序入口地址

> 答案解析：中断向量地址，即存储中断向量的存储单元地址，中断服务例行程序入口地址的地址。

4. 操作系统处理中断的流程包括（）
- [x] 执行相应的中断处理程序
- [x] 保护当前正在运行程序的现场 分析是何种中断，以便转去执行相应的中断处理程序 
- [x] 执行相应的中断处理程序 
- [x] 恢复被中断程序的现场

> 答案解析：（知识点：3.3中断、异常和系统调用比较）解释：中断是异步产生的，会随时打断应用程序的执行，且在操作系统的管理之下，应用程序感知不到中断的产生。所以操作系统需要保存被打断的应用程序的执行现场，处理具体的中断，然后恢复被打断的应用程序的执行现场，使得应用程序可以继续执行。 以ucore OS为例（lab5实验），产生一个中断XX后，操作系统的执行过程如下： vectorXX(vectors.S)--> \_\_alltraps(trapentry.S)-->trap(trap.c)-->trap\_dispatch(trap.c)-->-->……具体的中断处理-->\_\_trapret(trapentry.S) 通过查看上述函数的源码，可以对应到答案1-4。另外，需要注意，在ucore中，应用程序的执行现场其实保存在trapframe数据结构中。

5. 下列程序工作在内核态的()
- [x] 系统调用的处理程序
- [x] 中断处理程序
- [x] 进程调度
- [x] 内存管理

> 答案解析：这里说的“程序”是一种指称，其实就是一些功能的代码实现。而1-4都是操作系统的主要功能，需要执行相关的特权指令，所以工作在内核态。 以ucore OS为例（lab5实验），系统调用的处理程序在kern/syscall目录下，中断处理程序在kern/trap目录下，进程调度在kern/schedule目录下，内存管理在kern/mm目录下。

6. 以下关于系统调用和常规调用的说法中，错误的是（）
- [ ] 系统调用一般比常规函数调用的执行开销大
- [ ] 系统调用需要切换堆栈
- [ ] 系统调用可以引起特权级的变化
- [x] 常规函数调用和系统调用都在内核态执行

> 答案解析：系统调用相对常规函数调用执行开销要大，因为这会涉及到用户态栈和内核态栈的切换开销，特权级变化带来的开销，以及操作系统对用户态程序传来的参数安全性检查等开销。如果发出请求的请求方和应答请求的应答方都在内核态执行，则不用考虑安全问题了，效率还是需要的，直接用常规函数调用就够了。 以ucore OS为例，我们可以看到系统调用的开销在执行“int 0x80”和“iret”带来的用户态栈和内核态栈的切换开销，两种特权级切换带来的执行状态（关注 kern/trap/trap.h中的trapframe数据结构）的保存与恢复等（可参看 kern/trap/trapentry.S的__alltraps和__trapret的实现）。而函数调用使用的是"call"和“ret”指令，只有一个栈，不涉及特权级转变带来的各种开销。如要了解call, ret, int和iret指令的具体功能和实现，可查看“英特尔 64 和 iA-32 架构软件开发人员手册卷 2a's,指令集参考（A-M）”和“英特尔64 和 iA-32 架构软件开发人员手册卷 2B’ s,指令集参考（N-Z）”一书中对这些指令的叙述。

## 第五讲 物理内存管理：连续内存分配

1. 在使能分页机制的情况下，更合适的外碎片整理方法是()
- [ ] 紧凑(compaction) 
- [ ] 分区对换(Swapping in/out)
- [x] 都不是

> 我选B，答案是C。因为分页机制不会有外碎片。

2. 描述伙伴系统(Buddy System)特征正确的是()
- [x] 多个小空闲空间可合并为大的空闲空间 
- [x] 会产生外碎片 
- [x] 会产生内碎片 
- [ ] 都不对

> 我选AC，答案是ABC。因为伙伴系统也会产生外碎片的。

## 第六讲 物理内存管理：非连续内存分配

1. 描述页管理机制正确的是()
- [x] 页表在内存中
- [x] 页可以是只读的
- [x] 页可以有特权级
- [ ] 上述说法都不对

> 答案解析：前三个都对。当然有的地方不太准确。在80386系统中，一级页表一定在内存中，但二级页表不一定在内存中。PDE和PTE都可以规定访问权限，不过只有U/S（用户/OS权限）和R/W（只读/可读可写）位。

2. 可有效应对大地址空间可采用的页表手段是()
- [x] 多级页表
- [x] 反置页表
- [ ] 页寄存器方案
- [ ] 单级页表

> 我选了ABC，答案是AB。为什么页寄存器不行？原因是：页寄存器和反置页表很像，但它们的一个区别是进程ID在地址转换中的使用。没有进程ID（也就是说页寄存器方案）时，页表占用的空间仍然是与进程数相关的（也就是每个进程对应一组页寄存器？）。反置页表的大小只与物理内存大小，与并发进程数无关。
采用页寄存器的硬件开销会很大。所以现在的通用CPU（包括64位的CPU）没有采用这种方式，大部分还是多级页表。由于有TLB作为缓存，效率还不错。

## 第七讲 实验二 物理内存管理

1. 80386 CPU保护模式下的特权级个数是() 
- [ ] 1
- [ ] 2
- [ ] 3
- [x] 4

> 我选了B，答案是D. 注意80386 CPU保护模式下的特权级个数是4个，分别为ring0～ring3，只是大部分操作系统只用了2个而已。

2. 在ucore OS的管理下，如果CPU在ring3特权级执行访存指令，读属于ring0特权级的数据段中的内存单元，将出现的情况是（）
- [ ] 产生外设中断
- [x] 产生访存异常
- [ ] CPU继续正常执行
- [ ] 系统重启

> 答案解析：将产生General Protection Fault异常

3. 在启动页机制后，不可能进行的操作包括（）
- [x] 取消段机制，只保留页机制
- [ ] 取消页机制，只保留段机制
- [ ] 取消页机制，也取消段机制
- [ ] 保留页机制，也保留段机制

> 答案解析：不可能取消段机制，只保留页机制。因为进入保护模式后，段机制是肯定存在的，这是为了向下兼容。

4. 给定一个虚页地址和物理页地址，在建立二级页表并建立正确虚实映射关系的过程中，需要完成的事务包括()
- [x] 给页目录表动态分配空间，给页表分配空间
- [x] 让页基址寄存器的高20位内容为页目录表的高20位物理地址
- [x] 在虚地址高10位的值为index的页目录项中的高20位填写页表的高20位物理地址，设置有效位
- [x] 在虚地址中10位的值为index的页表项中中的高20位填写物理页地址的高20位物理地址，设置有效位

> 答案解析：都对，还要设置更多的一些属性。
