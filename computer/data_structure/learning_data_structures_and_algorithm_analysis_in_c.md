# 《Data Structures and Algorithm Analysis in C》学习与刷题笔记

## 为什么要学习DSAAC？
事情起因是这样的：某个月黑风高的夜晚，下班的我走在黯淡无光、冷清无人的冲之大道上，同时心里冒出一个强烈的想法：我不要再过这种无休止地加班、整天干着繁重琐碎的事情的生活了！我要回去读书！我要考研！在接下来的一个多月中，我不断在考研和换工作之间徘徊，最后我得出一个结论：我不知道读研好还是换工作好，但我知道把自己感兴趣的知识学好总不会错。其实我们专业大二下学期上过数据结构这门课，但当时正值我迷茫和逃课的高峰期，所以我基本没去上过这门课，作业也没按时交，结果扣了很多平时分，并导致这门课的实验课成绩我排在班中倒数几名。现在经过面试和工作的洗礼，我终于意识到数据结构的重要性，同时我现在也很有兴趣去了解一下红黑树等数据结构的原理。因此，我翻出去年入职时购买的但除了写了个名字外从未翻过的《Data Structures And Algorithm Analysis in C》，决定系统学习一遍数据结构。（出来混的，迟早要还......）

## 为什么要刷DSAAC的习题？
在看DSAAC这本书时，我给自己订了一个小目标：刷完DSAAC的所有习题。为什么要刷习题呢？因为做习题能够加深对书中知识的理解，而且这些习题90%以上是编程题，正好可以锻炼自己的代码能力。还有一个原因是受《我是一只IT小小鸟》中的一篇文章《掉进读书的兔子洞》的影响。文章作者徐宥提出他的三个学习理念：
> 1. 什么东西都可以自学
> 2. 慢即是快，笨笨地做一遍题是学习的捷径
> 3. 知识就是力量，而读书学知识能够消除蒙昧，掌握改变世界的力量，所以是一件快乐的事情

而他确实也严格按照他的学习理念去做，因此他一字不漏地敲完不少书的程序，以及一题不漏地做完不少教材的习题。当他总结毕业时面试、考研和发paper的成功经验时，说了一句话：
> 总的来说，面试也好，考研也好，写论文也好，之所以能够比较顺利，我觉得都是大一大二一个键一个键敲出来的，也是大三一本书一本书读出来的。

我很认同徐宥的学习方法，因此打算认认真真地做一遍DSAAC的题，以扎实数据结构基础。

## 刷题代码的存放路径
这是我刷题代码的github地址：[https://github.com/whl1729/dsaac](https://github.com/whl1729/DSAAC)。

## 读书笔记

### 1. 最大子数组问题
书中给出了最大子数组问题的四种解法，时间复杂度分别是O(N^3), O(N^2), O(NlogN)和O(N)。

* O(N^3)解法。穷尽法。用下标组合(i, j)来表示第i到j个元素组成的子数组，遍历所有的子数组(i,j)，并计算出其元素之和，对比得最大值。
* O(N^2)解法。思路仍然是穷尽法。但对O(N^3)解法进行优化。O(N^3)解法包含太多重复性的工作，比如在计算子数组元素之和时，计算(i, j+1)时会重新计算一遍(i, j)，O(N^2)算法相当于把(i, j)的计算结果记录下来，计算(i, j+1)时就可以使用这个现成的计算结果。
* O(NlogN)解法。分治法。这种解法的思路时把大问题分解成两个相对小一些的问题，分别计算两个小问题的结果，然后汇总得到大问题的答案。把大数组均分成两个小数组，那么最大子数组必然位于左边、右边或中间这三个位置之一。
* O(N)解法。O(N)解法抓住了问题的本质：最大子数组从首元素到任意一个元素之间的总和永远大于0。根据这个性质，O(N)解法只需从左到右扫描一遍数组，扫描时，先假设当前扫描元素就是最大子数组的元素，并即时计算当前数组元素之和。等到计算结果不大于0后，可以舍弃当前子数组，从下一个元素开始重复统计。我认为O(N)解法比O(NlogN)解法更优的主要原因是前者更抓住了问题的本质。

### 2. 数学证明方法

1. 数学归纳法
2. 反证法

### 3. 递归的基本规则

1. 基准情形。必须存在不需递归就能解决的基准情形。
2. 不断推进。递归调用必须朝着基准情形的方向不断推进。
3. 设计法则。假设所有的递归调用都能生效。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

## 刷题笔记

### 1. 避免定义系统预留函数
写完习题3.9的代码后运行，每当我输入非法值时，总是提示"Segmentation fault (core dumped)"。大意是访问了非法内存。检查代码，已经进行了入参检查，没看出问题。使用gdb调试，发现每次运行到异常分支"error(...);"就抛出上述错误提示。error()是我用来输出错误提示信息的一个函数，其实现只是对printf的简单封装，应该没啥问题。最后，我使用printf代替error，结果就正常了。因此，估计error是C语言系统或编译器预留的一个函数，我自己重新定义这个函数后，实际上链接的时候还是链接到系统或编译器的那个函数去了，而那个函数的入参与我自定义的应该不一致，最后导致非法内存访问问题。

### 2. 链表删除结点的注意事项
1. 处理好待删结点的前驱和后继的赋值
2. 注意头结点的赋值是否需要更改

### 3. 避免重复释放内存
解决习题3.13时，在实现基数排序时，自己定义了两个链表数组，每次循环结束后把数组2拷贝到数组1，后面释放内存时分别对两个数组进行释放，结果由于重复释放内存导致系统崩溃！

### 4. 如何更高效地计算2^4000
习题3.9要求我们写一个整数算术运算包，并计算2^4000次方中含有0~9各位数字的数目。我用链表实现了整数的加法和乘法，然后使用简单的循环来实现幂运算:
```
for (cur_expo = 1; cur_expo < expo; cur_expo++)
{
    result = multiply_polynomials(first_poly, poly, &product_poly);
    if (SUCCESS != result)
    {
        printf("failed to multiply polynomial!\n");
        return result;
    }

    list_clear(first_poly);
    first_poly = product_poly;
    product_poly = NULL;
}
```
在运行时，计算2的1000次方花费大约十几秒，计算2的4000次方则电脑卡住超过半小时。于是我开始考虑采取性能更好的算法。我当时的直觉是不断的平方，那么很快就能算到4000次方了。沿着这个方向想下去，还真让我想到一个简单而性能更好的算法：
```
1. 将4000化成二进制形式(1111,1010,0000)，即4000 = 2^11 + 2^10 + 2^9 + 2^8 + 2^7 + 2^5
2. 创建数组a[k]（0<=k<12），令a[k]=2^(2^k)，显然a[k+1] = a[k]^2，所以通过12次循环即可计算出a[k]各项的值。
3. 2^4000 = a[11] + a[10] + a[9] + a[8] + a[7] + a[5]
```
编写代码实现这个算法后，编译运行，计算2的10000次方耗时不到1秒！说明时间性能得到明显改善。这道题让我感受到了算法的力量！

![](http://images2017.cnblogs.com/blog/866895/201710/866895-20171026031213473-594823117.png)

### 5. 反转链表原来这么简单
习题3.12要求我们实现链表的反转，一开始我还以为有点麻烦，最后写完代码发现，原来反转链表的主要代码（循环体内的语句）只有4行，没想到这么简单！其实思路确实简单，就是保持原来的首节点不变，不断删除原首节点的下一节点并在表头插入。（以下代码省略了指针判空处理）
```
    struct list *prev = head->next;
    struct list *cur = prev->next;

    while (NULL != cur)
    {
        prev->next = cur->next; 
        cur->next = head->next;
        head->next = cur;
        cur = prev->next;
    }
```

### 6. 埋伏在缓冲区的'\n'
做习题3.20，发现第二次输入表达式时出现异常，代码片段大概如下：
```
while (go_on == 'y')
{
    memset(infix_expr, 0, MAX_EXPR_LEN);
    memset(post_expr, 0, MAX_EXPR_LEN);

    printf("Enter infix expression:\n");
    get_line(infix_expr);

    infix_to_postfix(infix_expr, post_expr);

    printf("The postfix expression:\n%s\n", post_expr);

    printf("Continue?('y' or 'n'): ");
    scanf(" %c", &go_on);
}
```
当第一次循环走到最后，我输入'y'后，进入第二次循环，但我还没来得及输入新的表达式，就直接跑到后面让我再次确认是否Continue了。经分析明白了原因：我输入'y'然后按Enter键时，'y'字符被scanf读取了，而紧跟着的'\n'则留在stdin缓冲区中。当我下一次循环想读取stdin的表达式时，遇到'\n'就直接停止读取了。目前我的解决方案是在scanf下面增加一次getchar()，把stdin的'\n'先输出来。

### 7. 如何确定链表遍历的终止条件
* 不设置哨兵、非循环链表：当指针为空时终止，即`while (cur != NULL)`
* 不设置哨兵、循环链表：当指针的next元素指向首元素时终止，即`while (cur->next != first)`
* 设置哨兵：当指针等于尾哨兵节点时终止，即`while (cur != tail)`

### 8. C语言的链表实现如何支持多类型？
* 目前我实现链表的方式大概是：链表的头文件声明中，数据类型均声明为void类型，在初始化链表时传入数据类型的大小，并保存在list\_data\_size这个全局变量中。这导致我在一个源文件中使用链表时，只能定义一种数据类型的链表。

* 我想到的一种解决方案：不使用全局变量来存储数据类型大小，而通过函数传参的方式传入数据类型大小。但这样的话，每个链表的接口都需要增加data\_size这个变量，感觉有点丑陋。有待思考更好的解决方法。

### 9. 局部变量名与全局变量名重复导致隐藏的bug
做习题3.20时，发现某个函数里获取运算符的优先级出错。我是这样求运算符的优先级：定义一个数组prio，存储所有运算符的优先级，因此只需用运算符来索引数组prio即可。我明明定义了`prio['+']=2`，但在该函数中获取到的值却为0。后来终于找到原因：我在该函数中也定义了局部变量prio，从而覆盖了全局数组prio。这个故事给我的启示：1. 尽量少用全局变量；2. 实在要用全局变量，其命名最好避免与局部变量冲突，可以加个g\_前缀来区分。

### 10. 后缀表达式转中缀表达式
习题3.20第3问是将后缀表达式转为中缀表达式。我觉得这一问有点难度，主要是要考虑有括号的情况。（但课本并没用星号标记这一问，说明作者认为并不困难，也说明......我很菜）。最后我花了好几天下班时间才完成这一问，下面记录下我的解法。
1. 用链表存储表达式，表达式的元素是char型，可能是运算数或运算符。
2. 当读入一个运算数时，若链表中的尾元素也是运算数或右括号，则说明此处需要插入一个运算符，但这个运算符要在后面才能知道，因此先插入一个空字符串，然后插入当前运算数。
3. 当读入一个运算符时，从后往前搜索链表，找到第一个空字符串的位置，修改其值为当前运算符。此时，还要判断是否需要插入括号，见第4步。
4. 第3步已经找到运算符应该插入的位置，这个位置将表达式分为左右两个子表达式。分别求出两个子表达式的最低优先级的运算符，若小于当前运算符的优先级，则需要给子表达式添加括号。

解这道题的收获：
1. Don't Quit! 做第3问时一度想放弃，后来想出解决方案后又觉得很有趣。要继续保持编程训练，继续培养编程的兴趣。
2. 在思考添加括号的问题时，我一开始想到多重括号嵌套的情形，感觉很难处理。后来使用抽象的方法，在考虑给当前运算符左右两边的子表达式添加括号时，将已含有括号的表达式简化成一个操作数，这样再思考问题就简单了。

### 11. 申请内存时误将指针当结构体导致释放内存时程序崩溃

### 12. 循环双链表初始化时的一个bug

### 13. 是时候学习vim的代码开发技巧了

### 14. 摘录邓俊辉课堂中关于栈的应用的总结

### 15. 表达式树

### 16. 二叉搜索树的一个命名问题


