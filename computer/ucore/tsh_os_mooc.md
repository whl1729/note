# 清华大学OS MOOC笔记

## 第十五讲 处理机调度

1. 时间片经验值：10毫秒


## 第十七讲 同步互斥

1. 共享变量可以被多个进程访问，并且不需要互斥访问，可以访问的进程既可以是系统进程，也可以是用户进程。

2. 什么叫同步原语？

3. 生产者-消费者问题：第十八讲

## 第十八讲 信号量与管程

1. 自旋锁 vs 信号量
    * 前者是通过硬件方式实现，后者是通过OS实现

2. 多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个？

3. 信号量、管程未掌握？
    * 采用面向对象方法，简化了线程间的同步控制
    * 任一时刻最多只有一个线程执行管程代码
    * 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复

4. 屏蔽中断 cli  使能中断 sti

5. 哲学家问题

## 第二十讲 死锁与进程通信

1. 目前大多数操作系统不负责死锁处理，因其开销较大。

## 第二十一讲

1. 每个进程维护自己的文件指针。

2. 内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。

## 第二十二讲

1. 文件系统的抽象
    * 文件
    * 目录项
    * 索引节点
    * 安装点

## 疑问：

1. 第7.2节 “了解特权级切换过程”没看懂？用户态和内核态的切换也没理解？既然用户态可以通过系统调用切换到内核态，那么设置内核态究竟有什么用？是避免用户使用除系统调用外的其他方式来执行任意指令吗？
    * 基址（Base address）一直被存放在隐藏部分。直到选择子发生变化，才会更新基址内容（即新的段表项中的基址值）。（不理解？）
    * 在Linux中，用户态和内核态使用的是不同的栈，两者各自负责各自的函数调用，互不干扰。当进行用户态与内核态的切换时，当前栈也要切换。
    * 当0x80号中断发生时，CPU除了切入内核态之外，还会自动完成以下事情：找到当前进程的内核栈（每一个进程都有自己的内核栈）、在内核栈中依次压入用户态的寄存器SS、ESP、EFLAGS、CS、EIP。

2. 对进程的内存分配细节尚不清楚，比如：每个进程占用的内存是多少？分配流程是怎样的？如何保证不同进程的内存隔离？进程的函数栈帧可能会被换出到磁盘中吗？分配内存时，需要先在磁盘中分配足够空间，也就是足够的物理页，再将物理页拷贝到内存中得到虚拟页吗？
    *  Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。(见[Linux进程地址空间 && 进程内存布局](https://blog.csdn.net/yusiguyuan/article/details/45155035)）
    * 存储在磁盘中的程序需要读入到内存后才能运行。
    * 把磁盘的内容读出到内存称为Page In，把内存的内容写入磁盘称为Page Out。
    * 可执行文件中并不存在栈及堆，栈及堆的内存空间都是在程序运行时得到申请分配的。

3. 为什么IDT表存的是段选择子而不是直接存段基址？
