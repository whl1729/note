# 如何阅读代码

本文记录自己阅读代码的一些心得体会。

## 2021/02/07

### 如何进行源码分析

#### 为什么进行源码分析？目的何在？

目前想到以下两个主要目标：

- 需要熟悉源码，从而在源码的基础上二次开发或重构。
- 需要学习源码的编程框架、编程规范、设计思想、实现原理等，从而提高技术能力。

#### 怎样才算熟悉源码？

- 理解软件是怎样编译构建的
- 理解软件是怎样安装部署的
- 理解软件是怎样运行的
- 理解软件是怎样实现的
- 理解软件有哪些应用场景
- 理解软件的用户体验
- 理解软件的质量如何
  - 正确性
  - 健壮性
  - 可靠性
  - 性能
  - 清晰性
  - 可维护性
  - 可测试性
  - 可拓展性
  - 兼容性
  - 可移植性
  - 安全性

#### 一份源码可能有哪些值得学习的地方？

- 设计思想
- 实现原理
- 编程框架
- 编程规范
- 编程技巧

## 2019/05/08 注意头文件及其所在路径

今天阅读C++ STL源代码，在阅读/usr/include/c++/7/bits/allocator.h文件中allocator类的定义时，遇到一个宏目录`_GLIBCXX_VISIBILITY(default)`，但在当前目录或上一级目录下都找不到其定义。于是到网上搜索了约1小时，终于在/usr/include/x86_64-linux-gnu/c++/7/bits/c++allocator.h文件中找到了。后来发现其实allocator.h文件开头就`#include <bits/c++allocator.h>`，如果我之前留意到这个信息的话，应该可以更快找到答案。教训：在当前路径下找不到变量声明或定义时，考虑其他头文件搜索路径。

## 2019/03/02 分析关键数据结构和关键接口，理解处理逻辑

今早看ucore lab 8文件系统的代码，很难看懂。后来意识到自己对整个处理逻辑几乎是一无所知，自然很难看懂。那么如何才能看懂呢？首先可以针对代码实现的功能提出问题（比如说：给出一个文件名，如何找到该文件在硬盘中的位置？），然后分析关键数据结构（比如inode），并分析函数调用流程中对该数据结构的处理等等。

## 2019/02/23 善于观察、用心思考

阅读和分析代码时，要善于观察、用心思考，比如观察到输出结果跟以前有差异后，要主动结合代码来寻找原因。举例：ucore前3个实验执行`sudo make qemu`后，最终会不断打印“100 ticks”；第4~5个实验最终却是停留在monitor界面等待用户输入命令。为什么存在这样的差异？为什么lab4和lab5中不处理时钟中断了？今天突然有了这个疑问，然后查看代码，很快找到原因：initproc调用do_exit，do_exit调用panic，panic调用intr_disable屏蔽了IRQ中断，导致CPU不会再处理时钟中断。

## 2019/02/20 分析业务功能的实现流程

发现自己以前阅读代码只是按照代码流程一路看下来，但很少从业务功能方面来分析代码。比如阅读ucore代码，自己经常是从kern_init函数开始，从pmm_init到vmm_init再到proc_init，逐个函数看下来。但很少按照业务功能来阅读代码，比如说，时钟中断或串口中断功能的整个流程是怎样实现的等。以后要两种方法结合来阅读代码，这样对代码流程梳理得更清楚，对整个系统理解得也更透彻。

## 2019/02/17 分析能力和知识储备很重要

今天在做ucore lab 5，卡在一个问题上，耗费好几个小时才弄明白。问题是这样的：根据代码，用户进程会在\_binary_obj___user_exit_out_start变量的地址处读取一个ELF文件，而我查找整个代码目录也没发现这个变量是怎么定义出来的。后来查看ucore_os_docs才明白这应该是链接器的名字修饰机制导致的。如果自己对链接器的名字修饰机制早有了解的话，这个问题应该可以更快地解决。教训：理性思考，想不出来则借助Google或其他资料；储备更多技术知识。

## 2018/12/18 由简入繁

阅读源代码时，可以采用由简入繁的方法，先忽略各种异常处理，理清主干代码。比如阅读迷宫寻径的代码，不妨先考虑没有任何障碍物，一条路走到底，这样可以撇开各种异常情况，理清楚基本路径，然后再逐步考虑各种异常情况，就容易多了。

