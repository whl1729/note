# 清华大学OS MOOC笔记

## 资源

1. [OS2018Spring课程资料首页](http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring)

2. [MOOC OS习题集](https://xuyongjiande.gitbooks.io/os_exercises/content/index.html)

3. [OS课堂练习](https://chyyuu.gitbooks.io/os_course_exercises/content/)

## 第一讲 操作系统概述

1. 操作系统内核包括串口驱动、磁盘驱动、字符设备I/O、块设备I/O等。

2. 内核特征
    * 并发
    * 共享
    * 虚拟
    * 异步

## 第二讲 实验零 操作系统实验环境准备

1. 双向链表结构原理

2. [type \*)0)->member in C?](https://stackoverflow.com/questions/13723422/why-this-0-in-type0-member-in-c):   
The pointer to zero is used to get a proper instance, but as typeof is resolved at compile-time and not at run-time the address used in the pointer doesn't have to be a proper or valid address.

3. 比较文件差异：meld

## 第三讲 启动、中断、异常和系统调用

1. 实模式下地址总线只有20根，此时地址空间只有1MB。

2. BIOS启动固件
    * 基本输入输出的程序
    * 系统配置信息，比如从哪里启动（磁盘、U盘、光盘等）
    * 开机后自检程序
    * 系统自启动程序
    * 将加载程序BootLoader从磁盘的引导扇区加载到0x7c00

3. 为什么不直接由BIOS加载操作系统，而是先由BIOS加载BootLoader，而BootLoader再去加载操作系统？答：不同操作系统的文件系统不同，BIOS不可能全部能识别。

4. BIOS在加载BootLoader前需进行的工作
    * BIOS读取主引导扇区代码，得到主引导记录
    * 主引导扇区代码读取活动分区的引导扇区代码

5. 硬件自检主要检测内存和显卡等关键部件的存在或工作状态。

6. BIOS有一个ESCD表，扩展系统配置数据。

7. BIOS系统调用：只能在x86的实模式下访问。BIOS以中断调用的方式 提供了基本的I/O功能。
    * INT 10h: 字符显示
    * INT 13h: 磁盘扇区读写
    * INT 15h: 检测内存大小
    * INT 16h: 键盘输入

8. BIOS初始化过程
    * 硬件自检POST
    * 检测系统中内存和显卡等关键部件的存在和工作状态
    * 查找并执行显卡等接口卡BIOS，进行设备初始化；
    * 执行系统BIOS，进行系统检测（检测和配置系统中安装的即插即用设备）
    * 更新CMOS中的扩展系统配置数据ESCD
    * 按指定启动顺序从软盘、硬盘或光驱启动

9. 中断、异常和系统调用比较
    * 源头
        * 中断：外设
        * 异常：应用程序意想不到的行为
        * 系统调用：应用程序请求操作提供
        * 服务
    * 响应方式
        * 中断：异步
        * 异常：同步
        * 系统调用：异步或同步
    * 处理机制
        * 中断：持续，对用户应用程序
        * 是透明的
        * 异常：杀死或者重新执行意想不到的
        * 应用程序指令
        * 系统调用：等待和持续

10. 函数调用和系统调用的不同处
    * 系统调用：INT和IRET指令用于系统调用。系统调用时，需要堆栈切换和特权级的转换
    * 函数调用：CALL和RET用于常规调用。常规调用时没有堆栈切换。

11. 可屏蔽中断 vs 不可屏蔽中断
    * 80386有两根引脚INTR和NMI接受外部中断请求信号。
    * INTR接受可屏蔽中断请求。 NMI接受不可屏蔽中断请求。
    * 在80386中，标志寄存器EFLAGS中的IF标志决定是否屏蔽可屏蔽中断请求。

12. 异常进一步分类为故障(Fault)、陷阱(Trap)和中止(Abort)。

13. 中断向量（参考[LINUX-内核-中断分析](https://blog.csdn.net/haolianglh/article/details/51946687)）
    * 每个中断和异常是由0～255之间的一个数来标识。在Intel中，把这个8位的无符号整数叫做一个向量（vector），所以，x86中中断和异常都有自己的向量。其中，异常和非屏蔽中断两者的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。
    * x86体系结构的异常和非屏蔽中断占用了0～19这20个中断向量。且其中仅有2号向量用于非屏蔽中断，其余19个全部分类为异常。
    * 128（即0x80）号向量被系统调用占用。不同系统调用通过系统调用号进一步区分。执行int指令前系统调用号会被放置在某个固定的寄存器中，比如Linux的系统调用号是由eax传入的。
    * 在x86体系中，外部可屏蔽中断，也就是物理IRQ所对应的中断向量号，占用了32～238这个范围（128系统调用除外）。 

> 问题： 加电后是否使能了中断机制？理由？

## 第四讲 实验一 BootLoader启动ucore os

1. BootLoader存放在一个512字节的扇区。

2. 有些中断源是不可屏蔽的。

3. 中断向量表的建立和初始化工作是由BIOS在计算机启动时完成的。当计算机启动后，操作系统和用户程序再根据自己的需要，修改某些中断的入口地址，使它指向自己的代码。

4. 实模式下的地址空间缺乏保护机制。对于每一个由段寄存器的内容确定的“基地址”，一个进程总是能够访问从此开始64KB的连续地址空间，而无法加以限制。

5. 中断 Interrupts
    * 外部中断 External (hardware generated) interrupts：串口、硬盘、网卡、时钟、…
    * 软件产生的中断 Software generated interrupts：The INT n 指令，通常用于系统调用

6. 异常 Exceptions
    * 程序错误
    * 软件产生的异常 Software generated exceptions：INTO, INT 3 and BOUND
    * 机器检查出的异常S

7. 中断描述符表
    * 每个中断或异常与一个中断服务例程（Interrupt Service Routine ，简称ISR）关联，其关联关系存储在中断描述符表（Interrupt Descriptor Table，简称IDT）。
    * IDT的起始地址和大小保存在中断描述符表寄存器IDTR中。
    * 中断描述符表（IDT）中每个表项叫做一个门描述符，由8个字节组成，根据中断号可以找到对应的门描述符，根据门描述符中的段选择子可以在GDT表中查询对应的段描述符，得到段基址，再加上门描述符中的偏移，可以得到中断服务例程的地址。
    *  “门”的含义是指当中断发生时必须先访问这些“门”，能够“开门”（即将要进行的处理需通过特权检查，符合设定的权限等约束）后，然后才能进入相应的处理程序。
    * 在IDT中门描述符包括3种类型：中断门描述符、陷阱门描述符、任务门描述符。

8. 段描述符：长度为8个字节，含有3个主要字段：段基地址（base）、段长度（limit）和段属性。详见[数据段描述符和代码段描述符（一）](https://blog.csdn.net/longintchar/article/details/50489889)。

9. 系统调用：用户程序通过系统调用访问OS内核服务。如何实现：
    * 需要指定中断号
    * 使用Trap，也称Software generated interrupt
    * 或使用特殊指令 (SYSENTER/SYSEXIT)

10. 特权级：保护模式中最重要的一个思想就是通过分级把代码隔离了起来，不同的代码在不同的级别 ，使大多数情况下都只和同级代码发生关系。 Intel 的80286以上的cpu可以识別4个特权级(或特权层) ，0级到3级。数值越大特权越小。一般用把系统内核放在0级，系统的其他服务程序位于1、2级，3级则是应用软件。
    * [DPL,RPL,CPL 之间的联系和区别](https://blog.csdn.net/better0332/article/details/3416749)
    * [一个操作系统的实现:关于CPL、RPL、DPL](http://www.cnblogs.com/pang123hui/archive/2010/11/27/2309924.html)

> 注：以下第11~15点出自[保护模式和分段机制](https://github.com/chyyuu/ucore_os_docs/blob/master/lab1/lab1_3_2_1_protection_mode.md)

11. 分段机制涉及4个关键内容
    * 段描述符表（包含多个段描述符的“数组”）
    * 段描述符（描述段的属性）：数组元素。其中B/D位标记默认大小（0为16位，1为32位），TYPE是段类型，S是描述符类型。
    * 段选择子（段寄存器，用于定位段描述符表中表项的索引）：数组索引
    * 逻辑地址：由段选择子selector和段偏移offset组成

12. 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32)=2^46）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。

13. 通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。

14. 转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：
    * 分段地址转换：CPU把逻辑地址（由段选择子selector和段偏移offset组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address）。如果不启动分页存储管理机制，则线性地址等于物理地址。 
    * 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。

15. 数据段选择子的整个内容可由程序直接加载到各个段寄存器（如SS或DS等）当中。这些内容里包含了请求特权级（Requested Privilege Level，简称RPL）字段。然而，代码段寄存器（CS）的内容不能由装载指令（如MOV）直接设置，而只能被那些会改变程序执行顺序的指令（如JMP、INT、CALL）间接地设置。而且CS拥有一个由CPU维护的当前特权级字段（Current Privilege Level，简称CPL）。

## 第五讲 物理内存管理：连续内存分配

1. 内存管理的一些特点
    * 抽象：逻辑地址空间
    * 保护：独立地址空间
    * 共享：访问相同内存（比如多个进程共享同一个操作系统内核）
    * 虚拟化：更大的地址空间

2. 目前多数系统（如Linux）采用按需页式虚拟存储。

3. 物理地址空间 vs 逻辑地址空间：前者是硬件支持的地址空间，后者是在CPU运行的进程看到的地址。

4. CPU中的MMU负责进行逻辑地址和物理地址的转换。

5. 访问内存前需要进行地址检查，根据段基址寄存器中的起始地址base及段长度寄存器中的长度limit，来判断待访问地址是否合法。

6. 动态分区分配策略
    * 最先匹配（First-fit）
    * 最佳匹配（Best-fit）
    * 最差匹配（Worse-fit）

7. 碎片整理方法之一：分区对换（Swapping in/Out），即通过抢占并占用处于等待状态进程的分区，以增大可用内存空间。

8. 伙伴系统（Buddy System）
    * 若待分配空间不小于当前空闲分区的一半，则将当前空闲分区整块给该进程；否则将当前分区均分成两份，再继续比较。
    * 释放过程：把释放掉的块放入空闲块数组，合并满足合并条件的块。
    * 合并条件：大小相同（均为2^i）、地址相邻，低地址空闲块起始地址为2^(i+1)的位数。

## 第六讲 物理内存管理：非连续内存分配

1. 页帧 vs 页面
    * 页帧：帧，物理页面，Frame，Page Frame
    * 页面：页，逻辑页面，Page

2. 为什么每个进程都有一个页表？而不是共用？每个进程也都有一个页表基址寄存器吗(PTBR: Page Table Base Register)？
    * CSAPP中提到，这样每个进程的虚拟地址空间相互独立。
    * 操作系统需要为每个进程维护一个页表，页表给出了该进程的每一页对应的物理地址。处理器必须知道如何访问当前进程的页表，因此每个进程都需要一个PTBR来保存自己的页表地址。给出逻辑地址（页号，偏移量），处理器使用页表产生物理地址（页框号，偏移量）。
    * 进程每一页在页表中都有一项，因此页表可以很容易地按页号对进程的所有页进行索引（从0页开始）。（伍注：“进程每一页”应该是指进程需要使用的有效页面，而不包括它不需要使用的页面，不然每个进程的页表都记录所有页面，会浪费内存）
    * 操作系统为当前内存中未被占用、可供占用的所有页框（即物理页）维护一个空闲页框列表。

3. 页表项标志：
    * 存在位（resident bit）：逻辑页面是否有一个物理页面与之对应，有则置1。
    * 修改位（dirty bit）
    * 引用位（reference bit）
    * 读/写位（Read/Write）
    * 用户/超级用户（User/Supervisor）

4. 逻辑页的存在位为0是什么状态？逻辑页是怎么初始化的？
    * 存在位为0意味着此逻辑页没有物理页面与之对应，或者说没有被分配物理页面。
    * CSAPP：存在位为0，还要看地址是否为空，空地址表示这个虚拟页没有被分配，非空地址则表示该虚拟页在磁盘上的起始位置。

5. TLB: Translation Look-aside Buffer，快表

6. 段页式存储管理中的内存共享：通过指向相同的页表基址，实现进程间的段共享。

7. 页寄存器和反置页面的思路：不让页表与逻辑地址空间的大小相对应，让页表与物理地址空间的大小相对应。

> 备注：第六讲第1、2、3、4道多选题答错

## 第七讲 实验二 物理内存管理
1. Linux和uCore特权级一般只用两级：Level 0（最高）和Level 3（最低）。

2. 特权级要求（未完全理解？）
    * 访问门时，CPL <= DPL[门] & CPL >= DPL[段]
    * 访问段时，max(CPL, RPL) <= DPL[段]

3. GDT占用空间较大，因此存放在内存中，而非CPU中。

4. CR0和CR3
    * CR3寄存器保存了页目表的起始地址（注：多级页表中，第一级是页目表PD，第二级是页表PT）
    * 为了在保护模式下使能页机制，OS需要置CR0寄存器中的bit 31（PG）。

5. 段选择子：共16位，第0~1位是RPL(Requested Privilege Level)，第2位是TI(Table Indicator, 0=GDT, 1=LDT)，第3~15位是Index，用于索引GDT表项获得段描述符。

5. 段表 vs 页表 vs GDT/LDT
（以下出自[进程中有多少个段表、多少个页表？](https://blog.csdn.net/yangkuiwu/article/details/53166283)）
    * 如果存储器采用基本分页机制，那么操作系统会为每个进程或任务建立一个页表（这个页表可能是一级的也可能是多级的）。整个操作系统中有多个进程在运行，那么系统就会有多个页表。页表在内存中的存储位置由寄存器CR3给出。
    * 如果存储器采用基本分段机制，那么操作系统会为每个进程或任务建立一个段表（一般不用多级），用于记录数据段、代码段等各类段在内存中的具体位置。
    * 如果采用段页式结合的机制，那么一般一个进程或任务，操作系统会给其建立一个段表，而段表中的每个段又会对应一个页表，也就是说，段页式机制的每个进程有一个段表，有多个页表。
    * 对于典型的linux系统而言，操作系统会维护一个全局描述符表（相当于系统的段表），全局描述符表中用于记录系统任务和用户任务的描述符，其中用户任务的描述符又指向用户任务的局部描述符表（相当于用户任务的段表）。

## 第八讲 虚拟存储概念

1. 分支局部性：一条跳转指令的两次执行，很可能跳到相同的内存位置。

2. 进程中未被访问的数据段和堆栈段可以存放在swap分区中。

3. 虚拟页式存储性能度量
    * 有效存储访问时间（effective memory access time, EAT） 
    * 缺页率p
    * 页修改概率q
    * 访存时间t0
    * 缺页异常处理时间t1（或者叫磁盘访问时间）
    * EAT = t0 * (1 - p) + t1 * p * (1 + q)

## 第九讲 页面置换算法

1. 页面锁定（frame locking）：描述必须常驻内存的逻辑页面，使用页面中的锁定标志来实现。

2. Belady现象：进程分配物理页面数增加时，缺页并不一定减少

3. 优化的时钟置换算法：不理解为什么可以没写回却将修改位清零？

4. Belady现象：何时有？何时没有？

5. 常驻集：不理解

## 第十一讲 进程和线程

1. 进程 vs 程序
    * 程序 = 文件 (静态的可执行文件)
    * 进程 = 执行中的程序 = 程序 + 执行状态
    * 进程的组成包括程序、数据和进程控制块
    * 同一个程序的多次执行过程对应为不同进程

2. 线程：允许进程内多个执行流并行运行，并且能共享。

## 第十二讲 进程控制

1. 每次进程切换时CPU都要执行一些指令，这是进程切换的开销之一。

2. 同一个等待队列里的各个进程等待的事件相同吗？为什么发生事件后此队列的所有进程都被唤醒？

3. 所有进程切换都会进入schedule函数中

> 备注：向勇老师用的代码编辑器是什么？感觉Butterfly Graph显示函数调用关系功能不错。

## 第十三讲 实验四 内核线程管理

1. 进程/线程上下文就是CPU内部寄存器的信息，包括eip，esp，ebx等寄存器。

2. begin schedule --> unable reschedule，这里不理解是干啥？


## 第十四讲 实验五 用户进程管理

1. ELF文件加载到内存：加载各个section、分配BSS段、分配堆栈空间。

## 第十五讲 处理机调度

1. 时间片经验值：10毫秒


## 第十七讲 同步互斥

1. 共享变量可以被多个进程访问，并且不需要互斥访问，可以访问的进程既可以是系统进程，也可以是用户进程。

2. 什么叫同步原语？

3. 生产者-消费者问题：第十八讲

## 第十八讲 信号量与管程

1. 自旋锁 vs 信号量
    * 前者是通过硬件方式实现，后者是通过OS实现

2. 多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个？

3. 信号量、管程未掌握？
    * 采用面向对象方法，简化了线程间的同步控制
    * 任一时刻最多只有一个线程执行管程代码
    * 正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复

4. 屏蔽中断 cli  使能中断 sti

5. 哲学家问题

## 第二十讲 死锁与进程通信

1. 目前大多数操作系统不负责死锁处理，因其开销较大。

## 第二十一讲

1. 每个进程维护自己的文件指针。

2. 内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。

## 第二十二讲

1. 文件系统的抽象
    * 文件
    * 目录项
    * 索引节点
    * 安装点

## 疑问：

1. 第7.2节 “了解特权级切换过程”没看懂？用户态和内核态的切换也没理解？既然用户态可以通过系统调用切换到内核态，那么设置内核态究竟有什么用？是避免用户使用除系统调用外的其他方式来执行任意指令吗？
    * 基址（Base address）一直被存放在隐藏部分。直到选择子发生变化，才会更新基址内容（即新的段表项中的基址值）。（不理解？）
    * 在Linux中，用户态和内核态使用的是不同的栈，两者各自负责各自的函数调用，互不干扰。当进行用户态与内核态的切换时，当前栈也要切换。
    * 当0x80号中断发生时，CPU除了切入内核态之外，还会自动完成以下事情：找到当前进程的内核栈（每一个进程都有自己的内核栈）、在内核栈中依次压入用户态的寄存器SS、ESP、EFLAGS、CS、EIP。

2. 对进程的内存分配细节尚不清楚，比如：每个进程占用的内存是多少？分配流程是怎样的？如何保证不同进程的内存隔离？进程的函数栈帧可能会被换出到磁盘中吗？分配内存时，需要先在磁盘中分配足够空间，也就是足够的物理页，再将物理页拷贝到内存中得到虚拟页吗？
    *  Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。(见[Linux进程地址空间 && 进程内存布局](https://blog.csdn.net/yusiguyuan/article/details/45155035)）
    * 存储在磁盘中的程序需要读入到内存后才能运行。
    * 把磁盘的内容读出到内存称为Page In，把内存的内容写入磁盘称为Page Out。
    * 可执行文件中并不存在栈及堆，栈及堆的内存空间都是在程序运行时得到申请分配的。

3. 为什么IDT表存的是段选择子而不是直接存段基址？


