# 《Tsinghua OS MOOC》第一~四讲笔记

## 资源

1. [OS2018Spring课程资料首页](http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring)

2. [uCore OS在线实验指导书](https://chyyuu.gitbooks.io/ucore_os_docs/content/)

3. [ucore实验基准源代码](https://github.com/chyyuu/ucore_os_lab)

4. [MOOC OS习题集](https://xuyongjiande.gitbooks.io/os_exercises/content/index.html)

5. [OS课堂练习](https://chyyuu.gitbooks.io/os_course_exercises/content/)

6. [Piazza问答平台](https://piazza.com/connect) 暂时无法注册

## 第一讲 操作系统概述

1. 操作系统内核包括串口驱动、磁盘驱动、字符设备I/O、块设备I/O等。

2. 内核特征
    * 并发
    * 共享
    * 虚拟
    * 异步

3. 操作系统需要管理的资源有：内存、进程及线程、处理机、文件系统。

4. 课程设计
    * ucore+模块化改进（可加载模块完善、动态链接库完善、内核功能的模块化改进）
    * 目前可以在树莓派上运行ucore，但对HDMI接口的支持不是很好

5. 操作系统为什么改变
    * 原则：设计随着各种相关技术的改变而做出一定的改变
    * 在过去二十年底层技术有极大的改变

6. 分时系统的CPU在不同程序之间调度，所以其CPU使用率相对多道程序系统有所下降，但能协调CPU使用时长不一的多个用户程序，提高了用户效率。

7. 微内核 vs 外核 VS 虚拟机
    * 微内核：尽可能把内核功能移到用户空间，用户模块间的通信使用消息传递
    * 外核：在内核里放更少的东西，只保留保护和隔离的作用，将资源管理的功能移到用户控件。
    * 虚拟机：在操作系统和硬件之间增加了一层虚拟机管理器（VMM）。虚拟机跟硬件打交道，操作系统跟虚拟机打交道。虚拟机负责资源的隔离，操作系统负责资源的管理。

## 第二讲 实验零 操作系统实验环境准备

1. ucore使用了面向对象的编程方法。
    * 面向对象编程方法。虽然ucore是用C语言开发的，但可以通过函数指针来建立一个通用的数据结构来提供统一的接口，而具体实现可以不一样。
    * 通用数据结构。如双向链表。

2. [type \*)0)->member in C?](https://stackoverflow.com/questions/13723422/why-this-0-in-type0-member-in-c):   
The pointer to zero is used to get a proper instance, but as typeof is resolved at compile-time and not at run-time the address used in the pointer doesn't have to be a proper or valid address.

3. 源码编辑工具
    * eclipse-CDT：基于Eclipse的C/C++集成开发环境、跨平台、丰富的分析理解代码的功能
    * Understand：跨平台、丰富的分析理解代码的功能

4. 源码比较工具：meld

5. qemu：硬件模拟器。可模拟多种CPU硬件环境，本实验中，用于模拟一台intel x86-32的计算机系统。

> qemu模拟x86-32时需要配置哪些东西？

6. 80386共有4种运行模式：实模式、保护模式、SMM模式和虚拟8086模式。

7. 物理地址 vs 线性地址
    * 物理内存地址空间：处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址，一个计算机系统只有一个物理地址空间
    * 线性地址空间：在操作系统的虚存管理下每个运行的应用程序能访问的地址空间，每个运行的应用程序都认为自己独享整个计算机系统的地址空间，这样可让多个运行的应用程序之间相互隔离
    * 逻辑地址空间：应用程序直接使用的地址空间
    * 段机制启动、页机制未启动：逻辑地址 -> 段机制处理 -> 线性地址 = 物理地址
    * 段机制和页机制都启动：逻辑地址 -> 段机制处理 -> 线性地址 -> 页机制处理 -> 物理地址 

## 第三讲 启动、中断、异常和系统调用

1. 实模式下地址总线只有20根，此时地址空间只有1MB。

2. BIOS启动固件
    * 基本输入输出的程序
    * 系统配置信息，比如从哪里启动（磁盘、U盘、光盘等）
    * 开机后自检程序
    * 系统自启动程序
    * 将加载程序BootLoader从磁盘的引导扇区加载到0x7c00

3. 为什么不直接由BIOS加载操作系统，而是先由BIOS加载BootLoader，而BootLoader再去加载操作系统？答：不同操作系统的文件系统不同，BIOS不可能全部能识别。（伍注：这里有点像分层的思想，为了适配各种不同操作系统的加载，在BIOS与操作系统之间加多一层boot loader，Boot loader来负责识别和加载各种系统，而BIOS的任务得以减轻，并且可以做得相对简单和稳定）

4. BIOS在加载BootLoader前需进行的工作
    * BIOS读取主引导扇区代码，得到主引导记录
    * 主引导扇区代码读取活动分区的引导扇区代码

5. BIOS初始化过程
    * 硬件自检POST
    * 检测系统中内存和显卡等关键部件的存在和工作状态
    * 查找并执行显卡等接口卡BIOS，进行设备初始化；
    * 执行系统BIOS，进行系统检测（检测和配置系统中安装的即插即用设备）
    * 更新CMOS中的扩展系统配置数据ESCD
    * 按指定启动顺序从软盘、硬盘或光驱启动

6. BIOS系统调用：只能在x86的实模式下访问。BIOS以中断调用的方式 提供了基本的I/O功能。
    * INT 10h: 字符显示
    * INT 13h: 磁盘扇区读写
    * INT 15h: 检测内存大小
    * INT 16h: 键盘输入

7. 中断、异常和系统调用比较
    * 源头
        * 中断：外设
        * 异常：应用程序意想不到的行为
        * 系统调用：应用程序请求操作提供
        * 服务
    * 响应方式
        * 中断：异步
        * 异常：同步
        * 系统调用：异步或同步
    * 处理机制
        * 中断：持续，对用户应用程序
        * 是透明的
        * 异常：杀死或者重新执行意想不到的
        * 应用程序指令
        * 系统调用：等待和持续

8. 函数调用和系统调用的不同处
    * 系统调用：INT和IRET指令用于系统调用。系统调用时，需要堆栈切换和特权级的转换
    * 函数调用：CALL和RET用于常规调用。常规调用时没有堆栈切换。

9. 可屏蔽中断 vs 不可屏蔽中断
    * 80386有两根引脚INTR和NMI接受外部中断请求信号。
    * INTR接受可屏蔽中断请求。 NMI接受不可屏蔽中断请求。
    * 在80386中，标志寄存器EFLAGS中的IF标志决定是否屏蔽可屏蔽中断请求。

10. 异常进一步分类为故障(Fault)、陷阱(Trap)和中止(Abort)。

11. 中断向量（参考[LINUX-内核-中断分析](https://blog.csdn.net/haolianglh/article/details/51946687)）
    * 每个中断和异常是由0～255之间的一个数来标识。在Intel中，把这个8位的无符号整数叫做一个向量（vector），所以，x86中中断和异常都有自己的向量。其中，异常和非屏蔽中断两者的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。
    * x86体系结构的异常和非屏蔽中断占用了0～19这20个中断向量。且其中仅有2号向量用于非屏蔽中断，其余19个全部分类为异常。
    * 128（即0x80）号向量被系统调用占用。不同系统调用通过系统调用号进一步区分。执行int指令前系统调用号会被放置在某个固定的寄存器中，比如Linux的系统调用号是由eax传入的。
    * 在x86体系中，外部可屏蔽中断，也就是物理IRQ所对应的中断向量号，占用了32～238这个范围（128系统调用除外）。 

> 问题： 加电后是否使能了中断机制？理由？

## 第四讲 实验一 BootLoader启动ucore os

1. BootLoader存放在一个512字节的扇区。

2. 有些中断源是不可屏蔽的。

3. 中断向量表的建立和初始化工作是由BIOS在计算机启动时完成的。当计算机启动后，操作系统和用户程序再根据自己的需要，修改某些中断的入口地址，使它指向自己的代码。

4. 实模式下的地址空间缺乏保护机制。对于每一个由段寄存器的内容确定的“基地址”，一个进程总是能够访问从此开始64KB的连续地址空间，而无法加以限制。

5. 中断 Interrupts
    * 外部中断 External (hardware generated) interrupts：串口、硬盘、网卡、时钟、…
    * 软件产生的中断 Software generated interrupts：The INT n 指令，通常用于系统调用

6. 异常 Exceptions
    * 程序错误
    * 软件产生的异常 Software generated exceptions：INTO, INT 3 and BOUND
    * 机器检查出的异常S

7. 中断描述符表
    * 每个中断或异常与一个中断服务例程（Interrupt Service Routine ，简称ISR）关联，其关联关系存储在中断描述符表（Interrupt Descriptor Table，简称IDT）。
    * IDT的起始地址和大小保存在中断描述符表寄存器IDTR中。
    * 中断描述符表（IDT）中每个表项叫做一个门描述符，由8个字节组成，根据中断号可以找到对应的门描述符，根据门描述符中的段选择子可以在GDT表中查询对应的段描述符，得到段基址，再加上门描述符中的偏移，可以得到中断服务例程的地址。
    *  “门”的含义是指当中断发生时必须先访问这些“门”，能够“开门”（即将要进行的处理需通过特权检查，符合设定的权限等约束）后，然后才能进入相应的处理程序。
    * 在IDT中门描述符包括3种类型：中断门描述符、陷阱门描述符、任务门描述符。

8. 段描述符：长度为8个字节，含有3个主要字段：段基地址（base）、段长度（limit）和段属性。详见[数据段描述符和代码段描述符（一）](https://blog.csdn.net/longintchar/article/details/50489889)。

9. 系统调用：用户程序通过系统调用访问OS内核服务。如何实现：
    * 需要指定中断号
    * 使用Trap，也称Software generated interrupt
    * 或使用特殊指令 (SYSENTER/SYSEXIT)

10. 特权级：保护模式中最重要的一个思想就是通过分级把代码隔离了起来，不同的代码在不同的级别 ，使大多数情况下都只和同级代码发生关系。 Intel 的80286以上的cpu可以识別4个特权级(或特权层) ，0级到3级。数值越大特权越小。一般用把系统内核放在0级，系统的其他服务程序位于1、2级，3级则是应用软件。
    * [DPL,RPL,CPL 之间的联系和区别](https://blog.csdn.net/better0332/article/details/3416749)
    * [一个操作系统的实现:关于CPL、RPL、DPL](http://www.cnblogs.com/pang123hui/archive/2010/11/27/2309924.html)

> 注：以下第11~15点出自[保护模式和分段机制](https://github.com/chyyuu/ucore_os_docs/blob/master/lab1/lab1_3_2_1_protection_mode.md)

11. 分段机制涉及4个关键内容
    * 段描述符表（包含多个段描述符的“数组”）
    * 段描述符（描述段的属性）：数组元素。其中B/D位标记默认大小（0为16位，1为32位），TYPE是段类型，S是描述符类型。
    * 段选择子（段寄存器，用于定位段描述符表中表项的索引）：数组索引
    * 逻辑地址：由段选择子selector和段偏移offset组成

12. 保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2^14个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32)=2^46）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。

13. 通过提供4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码数据的安全及任务的隔离。

14. 转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：
    * 分段地址转换：CPU把逻辑地址（由段选择子selector和段偏移offset组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address）。如果不启动分页存储管理机制，则线性地址等于物理地址。 
    * 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。

15. 数据段选择子的整个内容可由程序直接加载到各个段寄存器（如SS或DS等）当中。这些内容里包含了请求特权级（Requested Privilege Level，简称RPL）字段。然而，代码段寄存器（CS）的内容不能由装载指令（如MOV）直接设置，而只能被那些会改变程序执行顺序的指令（如JMP、INT、CALL）间接地设置。而且CS拥有一个由CPU维护的当前特权级字段（Current Privilege Level，简称CPL）。

