# 《设计模式的艺术》第5章学习笔记

参考CSDN博客：[史上最全设计模式导学目录](https://blog.csdn.net/LoveLion/article/details/17517213)

## 第5章 多态工厂的实现——工厂方法模式

1. 工厂方法模式的定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法让一个类的实例化延迟到其子类。
    - 软件实例：日志记录器，支持多种记录方式，比如文件记录或数据库记录

2. 简单工厂模式 vs 工厂方法模式
    - 简单工厂模式只提供一个工厂类，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类
    - 工厂方法模式不是提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构
    - 与简单工厂模式相比，工厂方法最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或具体类

3. 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。

4. 可以通过配置文件来存储具体工厂类的类名，这样更换新的具体工厂时无须修改源代码，系统扩展更为方便。

5. Java反射是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。

6. 主要优点
    - 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，***用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名***。
    - 能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。
    - 在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可

7. 主要缺点
    - 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，***系统中类的个数将成对增加***，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
    - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

8. 适用场景
    - 客户端不知道它所需要的对象的类
    - 抽象工厂类通过其子类来指定创建哪个对象

9. 实现方案
    - 定义一个抽象工厂类和一个抽象产品类
    - 对每一种产品，定义一个具体工厂类和一个具体产品类，分别继承于抽象工厂类和抽象产品类
