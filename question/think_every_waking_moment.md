# 只要醒着，就必须思考

大学时在图书馆看过著名华人数学家樊畿的一句口头禅：只要醒着，就必须思考数学。（ You have to think about mathematics every waking moment!---Ky Fan）这里化用作为本文的题目。本文用来记录自己每天思考的问题，领域不限，可以是计算机、数学、物理、经济学、心理学甚至足球。本文的初衷是促使自己养成勤于思考的习惯。

## Q6 深入理解设计模式（2019/4/26）

1. 问题详述：各种设计模式的意图、解决什么问题、怎样解决、应用实例、优缺点？

## Q5 三点共线问题（2019/4/17）

1. 问题详述：确定平面上的N个点中是否有任何三点共线，要求复杂度为O(N^2)

## Q4 最短距离问题（2019/4/17）

1. 问题详述：求出平面内N个点中距离最近的两个点，要求复杂度为O(N)

## Q3 红黑树被广泛使用的原因（2019/4/17）

1. 问题详述：红黑树为什么比AVL树等使用更广泛？

## Q2 全排列生成问题（2019/4/18～2019/4/25）

1. 问题详述：如何生成1～N的全排列？

2. 思考过程
    - 我记得大一有次参加“爱菲舞”周会前，有位同学捧着电脑在琢磨这个问题，那时我听完题目就跟他说“这很简单啊...”，然而事实上我根本不知道解法，后来也一直没有细想。
    - 上周在看《STL源码剖析》第6章“算法”的时候，里面介绍了permutation算法，瞥了一眼next_permutation的实现代码，看到需要从最后往回找一个更小的数字，然后立即不看了，先留着自己独立思考一下。所以说，这个问题也不能算是完全自己独立解决了，毕竟从最终解法来说，“从最后往回找一个更小的数字”是一个关键步骤。
    - 从2019/4/18开始，接下来几天我便利用零碎时间（主要是下午吃水果的时候）思考这个问题，由于从《STL源码剖析》知道next_permutation函数后，我已经知道这个算法的实现框架了：首先设置原始排列为升序排列，然后不断调用next_permutation函数生成下一个排列，直到最终生成的排列为原始排列时结束。那么问题的关键是如何实现next_permutation，也就是说：给定当前排列，如何找到下一个排列？
    - 我首先通过举例子来尝试找到思路：“1 2 3 4 5”的下一个排列是“1 2 3 5 4”，“2 1 3 5 4”的下一个排列是“2 1 4 3 5”，这里面有什么规律呢？第一个例子是将最后面的5跟前一位的4对调即可，第二个例子则需要调整最后三位。不难想象，有时只需调整最后几位，有时则需要调整很多位。没看出有啥规律。
    - 这样想了几天（每天只是吃水果的时候花几分钟时间来想），依然没有头绪。不过我隐隐约约得到一个结论：寻找下一个排列时，应该尽可能多地保持前面的数字不变，只调整最后的部分。但问题的难点在于：如何确认要调整的部分？
    - 2019/4/24，思路上突然有了重大进展：从后往前搜索，找到非递增处停下来，从非递增处到末尾，即为需要调整的部分。我无法得知自己如何想到这个思路，可能是我考虑到了极端场景：也就是说当后面的部分已经完全降序时，就无法通过只调整这部分而得到下一个排列了，必须继续往前搜索。得到这个思路后，我已经吃完梨了，因此没有继续思考下去，但我已经知道离最终答案很近了。
    - 2019/4/25，完善思路，得到最终解法：从后往前搜索，找到非递增处（记对应数字为a）停下来，从后面递增序列中找到第一个大于a的数字b，交换两者，再将后面部分翻转即可。晚上11点写代码验证了该思路是正确的。

3. 思路总结：该问题的关键在于确认哪部分需要调整，确认后就不难找到调整方案。回头看这个问题，我实际上对原问题进行了分解——原问题求下一个排列是什么，下一个排列可以看做是对当前排列某些数字进行调整得到的，所以换种问法就是：如何调整当前排列的某些数字，得到下一个排列？然而，我没有直接思考该问题，而是将问题分解为两个子问题：(1)需要调整哪里？(2)如何调整。知道要调整哪里后，就不难得到调整方案了。

4. 解题收获：举例子有助于找到问题的规律。如果原问题找不到思路，不妨将原问题分解成几个子问题，再逐个突破。

## Q1 最大子序列和问题（2019/4/17）

1. 问题详述：一个数组中的元素可正可负，求出其中的一个连续子序列，使得该子序列的和为所有子序列的和的最大值。输出最大值及子序列区间。

2. 思考过程：事实上我去年学习《数据结构与算法分析》时就看过这个问题，并知道它有几种复杂度不同的解法，其中最优解法的复杂度为O(n)。但现在我已经忘记最优解法了，只记得最优解法很巧妙。于是，2019年4月17日下午5点，我坐在深圳大学城图书馆外面的连廊的长椅上吃梨子，尝试重新找到这个问题的最优解法。
    - 我很快就意识到问题的第一个难点：在寻找这个子序列时，如果当前元素是正数，自然可以将其归入子序列，继续检查下一个；但如果当前元素是负数呢？是否将其归入子序列？就此刻而言，加入它将使得和变小，但说不定下一个元素是一个很大的正数呢？因此，首先需要解决一个问题：当检查到什么时候，可以确定必须结束当前子序列、从下一个元素开始检查下一个子序列了？
    - 然后我开始思考解的结构：假设我已经找到了这个子序列，它应该有什么特征？然后我很快发现了：这个子序列的真前缀或真后缀的和必然为正数，否则将真前缀或真后缀去掉后，得到的子序列的和将会更大，与假设矛盾。（这里的“真前缀”或“真后缀”是我现在总结时使用的术语，我当时使用的是“前面一部分”或“后面一部分”。）
    - 于是我找到了第一个问题的答案：当检查到当前子序列的和小于0时，可以结束当前子序列，从下一个元素开始检查下一个子序列了。这样，我们就可以识别出各个候选子序列，并在检查过程中记录其中的最大值即可

3. 思路总结：这个问题的关键在于识别出各个候选子序列之间是不会重叠的（因为如果两个候选子序列可以重叠的话，它们会被合并成一个子序列），而且各个候选子序列要么只有一个元素（此时其和可正可负），要么有多个元素（此时其和必为正数）。根据这个特点，不难找到各个候选子序列的分界点。

4. 解题收获：正向推理和逆向推理相结合，找出解的特征。在解决这道题时，我一开始正向推理，想直接找出子序列，推不下去后开始逆向推理，也就是从答案出发，我开始思考“假设找到了这个子序列，它应该有什么特征”，当发现解的特征后，就不难从正向找到这个解了。因此，有时正向推理遇到困难时，不妨逆向推理，分析解的特征有利于帮我们找到这个解。

5. 拓展：2019/4/25晚上睡觉前，翻看《编程珠玑》第8章，里面提到该问题的多种解法的探索过程：
    - 刚提出这个问题时，开发者使用蛮力法去遍历所有情况，复杂度为O(n^3)；
    - 后来发现实在太慢，于是很快找到两种复杂度为O(n^2)的算法，两种算法本质上还是蛮力法，但都进行了优化：算法a遍历时利用了先前的求和结果来计算当前的总和，算法b先依次求出前i个元素的和存储在一个数组中，求和时可以利用该数组进行简化；
    - 再后来发现了一种复杂度为O(nlogn)的算法，本质上是采用分治法；
    - 最后发现了复杂度为O(n)的算法，思路和我上面重新发现的思路一样。发现过程颇具传奇色彩：一次大会上几位开发者提出该问题并介绍它的几种解法（复杂度依次为O(n^3)、O(n^2)、O(nlogn)）后，一位听众只花了1分钟就找到了复杂度为O(n)的算法！这个世界上，还是牛人辈出的。
