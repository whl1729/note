# 《Data Structures and Algorithm Analysis in C》学习与刷题笔记

## 为什么要学习DSAAC？
某个月黑风高的夜晚，下班的我走在黯淡无光、冷清无人的冲之大道上，同时心里冒出一个强烈的想法：我不要再过这种无休止地加班、整天干着繁重琐碎的事情的生活了！我要回去读书！我要考研！在接下来的一个多月中，我不断在考研和换工作之间徘徊，最后我得出一个结论：我不知道读研好还是换工作好，但我知道把自己感兴趣的知识学好总不会错。数据结构是我们专业大二下学期的一门选修课，但当时正值我迷茫和逃课的高峰期，这门课也被我翘掉了，作业也没按时交。现在经过面试和工作的洗礼，我终于意识到数据结构的重要性，同时我现在也很有兴趣去了解一下红黑树等数据结构的原理。因此，我翻出去年入职时购买的但从未翻过的《Data Structures And Algorithm Analysis in C》，决定系统学习一遍数据结构。（出来混的，迟早要还......）

## 为什么要刷DSAAC的习题？
在看DSAAC这本书时，我给自己订了一个小目标：刷完DSAAC的所有习题。为什么要刷习题呢？因为做习题能够加深对书中知识的理解，而且这些习题90%以上是编程题，正好可以锻炼自己的代码能力。还有一个原因是受《我是一只IT小小鸟》中的一篇文章《掉进读书的兔子洞》的影响。文章作者徐宥提出他的三个学习理念：
> 1. 什么东西都可以自学
> 2. 慢即是快，笨笨地做一遍题是学习的捷径
> 3. 知识就是力量，而读书学知识能够消除蒙昧，掌握改变世界的力量，所以是一件快乐的事情

而他确实也严格按照他的学习理念去做，因此他一字不漏地敲完不少书的程序，以及一题不漏地做完不少教材的习题。当他总结毕业时面试、考研和发paper的成功经验时，说了一句话：
> 总的来说，面试也好，考研也好，写论文也好，之所以能够比较顺利，我觉得都是大一大二一个键一个键敲出来的，也是大三一本书一本书读出来的。

我很认同徐宥的学习方法，因此打算认认真真地做一遍DSAAC的题，以扎实数据结构基础。

## 刷题代码的存放路径
这是我刷题代码的github地址：[https://github.com/whl1729/dsaac](https://github.com/whl1729/DSAAC)。

## 学习进度

### 各章学习时间

#### 第3章
* 学习时间：2017年9月4日～2017年11月11日（69天）
* 阅读时间：2017年9月4日～2017年9月17日（14天）
* 做题时间：2017年9月18日～2017年11月11日（55天）

#### 第4章
* 学习时间：2017年11月12日～2018年1月18日（68天）
* 阅读时间：2017年11月13日～2017年11月26日（8天）
* 做题时间：2017年11月12日～2018年1月18日（60天）

#### 第5章
* 学习时间：2018年1月19日～2018年2月11日（17天）
* 阅读时间：2018年1月19日～2018年1月21日（3天）
* 做题时间：2018年1月21日～2018年2月11日（14天）

#### 第6章
* 学习时间：2018年3月12日～2018年3月31日（10天）
* 阅读时间：2018年3月12日～2018年3月31日（10天）

#### 第7章
* 学习时间：2018年3月29日～2018年4月1日
* 阅读时间：2018年3月29日～2018年4月1日

#### 第8章
* 学习时间：2018年3月19日～2018年3月25日（3天）
* 阅读时间：2018年3月19日～2018年3月25日（3天）

#### 第9章
* 学习时间：2018年2月23日～2018年3月25日（15天）
* 阅读时间：2018年2月23日～2018年3月25日（7天）
* 做题时间：2018年2月23日～2018年3月25日（7天）

### 2018年3月（1周没学习）
* 3月19日～3月25日：做完《数据结构与算法分析》第9章前29题中不用编程的会做的题目。读完第8章”不相交集合“。
* 3月12日～3月18日：做完《数据结构与算法分析》第9章“图”前5题。读完第6章”优先队列（堆）“。
* 3月5日～3月11日：每天加班到11点。读完《数据结构与算法分析》第9章“图“。

### 2018年2月（3周没学习）
* 2月23日～3月4日：加班较多。读完第9章“图算法”前5节。
* 2月12日～2月22日：过年，没学习数据结构。
* 2月5日～2月11日：本周主要在研究英语词源。完成《数据结构与算法分析》第5章第3题。
* 1月29日～2月4日：完成《数据结构与算法分析》第5章第3题第1问。

### 2018年1月（1周没学习）
* 1月22日～1月28日：本周主要在整理待记忆的单词，没学习数据结构。
* 1月15日～1月21日：完成《数据结构与算法分析》第4章第44题。读完第5章并完成8道习题。
* 1月8日～1月14日：完成《数据结构与算法分析》第4章第38~43题。
* 1月1日～1月7日：完成《数据结构与算法分析》第4章第37题“B树”。

### 2017年12月（半周没学习）
* 12月25日～12月31日：做《数据结构与算法分析》第4章第37题“B树”，尚未完成。
* 12月18日～12月24日：完成《数据结构与算法分析》第4章第30～36题。
* 12月11日～12月17日：周一发烧、周四至周六加班较晚。完成《数据结构与算法分析》第4章第27～29题。
* 12月4日～12月10日：完成《数据结构与算法分析》第4章前26题

### 2017年11月
* 11月27日～12月3日：做完《数据结构与算法分析》第4章splay树的编码、B树的设计及前6道习题
* 11月20日～11月26日：读完《数据结构与算法分析》第4章第3～6节，并完成二叉搜索树和AVL树的编码。
* 11月13日～11月19日：读完《数据结构与算法分析》第4章第2节并编码实现表达式树。
* 11月6日～11月12日：完成《数据结构与算法分析》第3章习题及读完第4章前2节。
* 10月30日～11月5日：完成《数据结构与算法分析》第3章第20题。

### 2017年10月
* 10月23日～10月29日：完成《数据结构与算法分析》第3章第14～19题。
* 10月16日～10月22日：完成《数据结构与算法分析》第3章第10～13题。
* 10月9日～10月15日：完成《数据结构与算法分析》第6～9题。
* 10月1日～10月8日：用github管理《数据结构与算法分析》习题代码。

### 2017年9月
* 9月25日～9月30日：完成《数据结构与算法分析》第3章第4～5题。
* 9月18日～9月24日：完成《数据结构与算法分析》第3章前3题。
* 9月11日～9月17日：读完《数据结构与算法分析》第3章。
* 9月4日～9月10日：读《数据结构与算法分析》第3章，尚未读完。

### 2017年8月
* 8月28日～9月3日：读完《数据结构与算法分析》前2章并完成习题。

## 读书笔记

### 1. 最大子数组问题
书中给出了最大子数组问题的四种解法，时间复杂度分别是O(N^3), O(N^2), O(NlogN)和O(N)。

* O(N^3)解法。穷尽法。用下标组合(i, j)来表示第i到j个元素组成的子数组，遍历所有的子数组(i,j)，并计算出其元素之和，对比得最大值。
* O(N^2)解法。思路仍然是穷尽法。但对O(N^3)解法进行优化。O(N^3)解法包含太多重复性的工作，比如在计算子数组元素之和时，计算(i, j+1)时会重新计算一遍(i, j)，O(N^2)算法相当于把(i, j)的计算结果记录下来，计算(i, j+1)时就可以使用这个现成的计算结果。
* O(NlogN)解法。分治法。这种解法的思路时把大问题分解成两个相对小一些的问题，分别计算两个小问题的结果，然后汇总得到大问题的答案。把大数组均分成两个小数组，那么最大子数组必然位于左边、右边或中间这三个位置之一。
* O(N)解法。O(N)解法抓住了问题的本质：最大子数组从首元素到任意一个元素之间的总和永远大于0。根据这个性质，O(N)解法只需从左到右扫描一遍数组，扫描时，先假设当前扫描元素就是最大子数组的元素，并即时计算当前数组元素之和。等到计算结果不大于0后，可以舍弃当前子数组，从下一个元素开始重复统计。我认为O(N)解法比O(NlogN)解法更优的主要原因是前者更抓住了问题的本质。

### 2. 数学证明方法

1. 数学归纳法
2. 反证法

### 3. 递归的基本规则

1. 基准情形。必须存在不需递归就能解决的基准情形。
2. 不断推进。递归调用必须朝着基准情形的方向不断推进。
3. 设计法则。假设所有的递归调用都能生效。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

## 未解决的问题

### 第9章 图算法

1. 第9.6.2节中的判断图的双向连通性算法，为什么Low(v)最多只能有一条back edge？

2. 习题9.4：使用双循环来初始化邻接矩阵需要O(|V|^2)的时间，请提出一个时间复杂度更低的使用邻接矩阵来存储图的方法？

## 刷题笔记

### 26. 如何想到拓扑排序的解法？
习题9.1要求对给出的图进行拓扑排序，我的思考过程如下：
1. 首先想到广度优先搜索，从起点s出发，首先遍历其邻节点，其次是邻节点的邻节点，以此类推。但很快发现不可行，因为无法确定s的邻节点的顺序，而往往邻节点是有依赖顺序的。比如s的邻节点有a、b和c，而a依赖于c，如果我把a排在前面就出错了。
2. 其次是深度优先搜索，从起点s出发，使用深度优先算法依次遍历每一条路径。此法也不可行。因为不同路径之间有重叠，很难合并。
3. 最后我通过把图转化为一棵自上而下的树，然后从上到下依次遍历节点，得到拓扑排序的一个结果。此法是可行的。

做完题目后，我开始思考拓扑排序的算法实现，没有思路，因此回头翻书，发现书中的解法很厉害很优雅：
首先定义节点的入度（indegree）为指向该节点的边的总数。然后拓扑排序的算法就是每次找出入度为0的节点，从图中删除该节点及其相关的边，并更新其邻节点的入度即可。

回头想了一下，其实我的解法本质上就是应用了书中的解法，只是我没能总结出这个本质而已。这个算法我确实很难想到，可能需要有一点图论的基础才容易想到。不过，这道题的关键是确定当前可以输出的节点的特征——入度为0。作个类比：一批官员出席会议，按照官职高低先后入场。那么，任意一位官员可以入场的前提是比他官职高的官员都已入场。

### 25. Bug 10：释放动态数组的元素导致程序崩溃
做习题4.37,时，我动态分配了一个数组，通过`tree_insert`接口将数组元素插入B树中，然后调用`tree_clear`接口依次删除B树的每个节点，结果程序崩溃了！后来推测原因如下：删除节点时，我调用`free`函数释放了数据的内存，而该数据是动态数组的其中一个成员。我申请内存时是为整个数组申请的一大块内存，而现在我试图释放其中的一小部分内存，这应该是被禁止的。估计C语言内存管理的机制是对用户申请的内存记录起始位置和长度，所以用户释放时也只能整块一起释放，不能单独释放中间的一小块。这里有待深入研究。

### 24. 有待研究：编程实现二叉树的图形化显示？
题目4.34要求编程实现绘画二叉树，需要首先实现画圆圈、画直线的程序。我大致了解到需要用到计算机图形学的知识，有点麻烦。考虑到这道题与数据结构的关系不大，暂时搁置，等后面有空再研究。

### 23. 重构：将打印错误信息的语句封装成一个宏
在判断异常分支时，为方便调试定位，我一般会打印出函数名字及出错那一行的行号，比如：
```
printf("%s(%d): null pointer!\n", __FUNCTION__, __LINE__);
```
后来发现每次都要写\_\_FUNCTION\_\_和\_\_LINE\_\_简直不能忍，因此定义了一个打印错误信息的宏：
```
#define ERR_MSG(format, ...)  printf("%s(%d)", __FUNCITON__, __LINE__); printf(format, __VA_ARGS__)
```
这样代码就清爽多了。所以说，要敢于重构，要clean code.

### 22. 使用三角函数时需要增加`-lm`编译选项

### 21. Bug 9: 删除节点后忘记更新父节点的孩子信息
做习题4.11时，自己好几处地方删除节点后忘记更新父节点的孩子信息。尤其是删除叶节点后，要将父节点的left/right置为NULL。

### 20. Bug 8: 内存拷贝后误释放内存
习题4.11要求使用游标（cursor）而非指针来实现二叉搜索树，在实现删除操作时，我犯了个误释放内存的错误，导致删除某个节点时误把其他节点也干掉了。。
```
/* error code: I want to delete right child, but delete right child's right child */
memcpy(g_arr + cur, g_arr + g_arr[cur].right, sizeof(Node));
cursor_free(g_arr[cur].right);
```
如上文代码段所示，我的初衷是把当前节点的右孩子节点拷贝到当前节点，然后删除右孩子节点，但结局是右孩子的右孩子节点壮烈牺牲了！正确做法是用临时变量保存右孩子节点的位置。
```
/* correct code */
right = g_arr[cur].right;
memcpy(g_arr + cur, g_arr + right, sizeof(Node));
cursor_free(right);
```

### 19. Bug 7: 误将`=`写成`==`导致赋值语句不生效
今天实现完splay tree的查找操作时，执行时运行结果不对。使用gdb调试时，发现有次调用`cmp_data()`函数时的返回结果有问题，看了好一会才意识到问题所在：自己多写了一个等号！结果调用完`cmp_data()`函数后，不是将返回值赋给`result`，而是将返回值与`result`作比较，然后默默地丢弃了比较结果，再执行下一个语句。因此，`result`的值根本没改变！两点体会：一是以后要细心些，二是C编译器未免太信任程序员了吧，遇到这种情况能不能报个警啊......（可能修改编译选项可以实现，有空研究下）。
```
int result = 0;

/* 多写了一个等号！*/
result == cmp_data((*tree)->data, data, size);
if (result == 0)
{
    /* do something. */
}
```

### 18. 如何用非递归的方式来实现AVL树？
几经周折，今天终于完成了AVL树的编码，并通过了自己的测试用例。我是用递归方式实现的，毕竟在更新树的高度等操作时使用递归会很方便。那么非递归方式又该如何实现呢？有空得思考下。

### 17. 学习数据结构真有趣
大二时我几乎逃掉了所有的数据结构课，而现在我自学数据结构时却发现原来它这么有趣。大概是敲代码刷掉一道道习题给我带来了成就感和自信心吧。毕竟经过努力我基本能解决掉所有的课后习题，虽然有些题目要思考较长时间。想起陶哲轩的一句话：“发展数学兴趣所要做的最重要的事情是有能力和自由与数学玩。”大抵编程也如此吧。管它呢，开心就好。最近开始学习树结构，我迫不及待地想弄懂AVL树、splay树、B+树和红黑树等各种树的原理，那感觉比森林探险时遇到一棵棵葱葱郁郁的、直插云霄的参天古树还要激动和欣喜呢！

### 16. 二叉搜索树的一个命名问题
在实现二叉搜索树的插入操作时遇到一个命名问题：我首先调用一个函数来查找应该插入的位置，假设要在节点cur下面插入，则插入的位置为`cur->left`或`cur->right`，但在命名这个函数和输入参数时有点纠结，总感觉不恰当。看来想个清晰易懂的命名也不容易啊。

### 15. 使用表达式树来实现前缀、中缀、后缀表达式的相互转换
本周开始学习第四章“树”，然后发现用表达式树来实现前缀、中缀、后缀表达式之间的相互转换貌似很方便，于是挽起袖子敲代码实现了一下，确实如此。基本思路是：先读入前缀、中缀或后缀表达式，将其转化为一颗表达式树。然后前序、中序和后序遍历此树将分别得到前缀、中缀和后缀表达式。

### 14. 邓俊辉《数据结构》中关于“栈的应用”的总结
最近晚上经常一边吃宵夜一边在“学堂在线”网站上面邓俊辉的《数据结构》公开课，目前看到邓老师讲解“栈的应用”部分，感觉总结得很到位，摘录笔记如下：

* 逆序输出问题：如进制转换。输入规模不确定的逆序输出问题，适合使用栈，因其具有“后进先出”特性及在容量方面的自适应性。

* 递归嵌套问题：如栈混洗、括号匹配。具有自相似性的问题多可嵌套地递归描述，但因分支位置和嵌套深度不固定，其递归算法的复杂度不易控制。栈结构及其操作天然地具有递归嵌套性，故可用以高效地解决这类问题。

* 延迟缓冲问题：如表达式求值。在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后，才能作出判断并实施计算。在这类场合，栈结构可以扮演数据缓冲区的角色。

* 逆波兰表达式：reverse Polish notation, RPN。数学表达式的一种，其语法规则可概括为：操作符紧邻于对应的操作数之后。

### 13. 是时候学习vim的代码开发技巧了
目前自己一直使用vim编辑器来写C语言代码，但对vim的许多强大功能并不熟悉，导致开发效率低下。是时候安装一些vim插件并学习类似IDE的代码开发技巧了。

### 12. Bug 6：循环双链表初始化时误将一维指针当二维指针
我在实现循环双链表时定义了两个哨兵：`head`和`tail`。初始化时，我首先调用`create_node(struct list **head, void *data)`接口创建了`head`节点。由于初始化时要将`head`和`tail`的`prev`和`next`指针均指向对方，因此我在创建`tail`节点时这样写：`result = create_node(head->next, data)`。我的本意是创建一个新节点并将其地址返回给`head->next`，但我的第一个入参应该写成`&head->next`而非`head->next`！我误把一维指针当做二维指针了！然而gcc编译器并没有报错，估计是默默地帮我执行了一维指针到二维指针的强制转换......

### 11. Bug 5：申请内存时误将指针当结构体导致释放内存时程序崩溃
在实现栈时，发现每次调用`stack_clear()`接口来释放内存时程序就会崩溃，一开始以为是重复释放内存或释放空指针导致的，但修改后依然崩溃，最后才发现原来自己在栈的初始化函数中有个严重的Bug：申请内存时，误将指针当结构体，结果只申请了一个指针的内存，也就是4字节，而我的栈节点实际需要8个字节！这件事使我意识到把Stack定义为结构体类型，比定义为结构体指针类型好些。虽然使用时要多一个星号，但可以避免诸如本次之类的错误。
```
// 这里的Stack是个指针！malloc的长度应该是sizeof(*stck)
Stack stck = NULL;
stck = (Stack)malloc(sizeof(Stack)); 
```
### 10. 后缀表达式转中缀表达式
习题3.20第3问是将后缀表达式转为中缀表达式。我觉得这一问有点难度，主要是要考虑有括号的情况。（但课本并没用星号标记这一问，说明作者认为并不困难，也说明......我很菜）。最后我花了好几天下班时间才完成这一问，下面记录下我的解法。
1. 用链表存储表达式，表达式的元素是char型，可能是运算数或运算符。
2. 当读入一个运算数时，若链表中的尾元素也是运算数或右括号，则说明此处需要插入一个运算符，但这个运算符要在后面才能知道，因此先插入一个空字符串，然后插入当前运算数。
3. 当读入一个运算符时，从后往前搜索链表，找到第一个空字符串的位置，修改其值为当前运算符。此时，还要判断是否需要插入括号，见第4步。
4. 第3步已经找到运算符应该插入的位置，这个位置将表达式分为左右两个子表达式。分别求出两个子表达式的最低优先级的运算符，若小于当前运算符的优先级，则需要给子表达式添加括号。

解这道题的收获：
1. Don't Quit! 做第3问时一度想放弃，后来想出解决方案后又觉得很有趣。要继续保持编程训练，继续培养编程的兴趣。
2. 在思考添加括号的问题时，我一开始想到多重括号嵌套的情形，感觉很难处理。后来使用抽象的方法，在考虑给当前运算符左右两边的子表达式添加括号时，将已含有括号的表达式简化成一个操作数，这样再思考问题就简单了。

### 9. Bug 4：命名冲突导致局部变量名覆盖全局变量名
做习题3.20时，发现某个函数里获取运算符的优先级出错。我是这样求运算符的优先级：定义一个数组prio，存储所有运算符的优先级，因此只需用运算符来索引数组prio即可。我明明定义了`prio['+']=2`，但在该函数中获取到的值却为0。后来终于找到原因：我在该函数中也定义了局部变量prio，从而覆盖了全局数组prio。这个故事给我的启示：1. 尽量少用全局变量；2. 实在要用全局变量，其命名最好避免与局部变量冲突，可以加个g\_前缀来区分。

### 8. C语言的链表实现如何支持多类型？
* 目前我实现链表的方式大概是：链表的头文件声明中，数据类型均声明为void类型，在初始化链表时传入数据类型的大小，并保存在list\_data\_size这个全局变量中。这导致我在一个源文件中使用链表时，只能定义一种数据类型的链表。

* 我想到的一种解决方案：不使用全局变量来存储数据类型大小，而通过函数传参的方式传入数据类型大小。但这样的话，每个链表的接口都需要增加data\_size这个变量，感觉有点丑陋。有待思考更好的解决方法。

### 7. 如何确定链表遍历的终止条件
* 不设置哨兵、非循环链表：当指针为空时终止，即`while (cur != NULL)`
* 不设置哨兵、循环链表：当指针的next元素指向首元素时终止，即`while (cur->next != first)`
* 设置哨兵：当指针等于尾哨兵节点时终止，即`while (cur != tail)`

### 6. Bug 3：埋伏在缓冲区的'\n'
做习题3.20，发现第二次输入表达式时出现异常，代码片段大概如下：
```
while (go_on == 'y')
{
    memset(infix_expr, 0, MAX_EXPR_LEN);
    memset(post_expr, 0, MAX_EXPR_LEN);

    printf("Enter infix expression:\n");
    get_line(infix_expr);

    infix_to_postfix(infix_expr, post_expr);

    printf("The postfix expression:\n%s\n", post_expr);

    printf("Continue?('y' or 'n'): ");
    scanf(" %c", &go_on);
}
```
当第一次循环走到最后，我输入'y'后，进入第二次循环，但我还没来得及输入新的表达式，就直接跑到后面让我再次确认是否Continue了。经分析明白了原因：我输入'y'然后按Enter键时，'y'字符被scanf读取了，而紧跟着的'\n'则留在stdin缓冲区中。当我下一次循环想读取stdin的表达式时，遇到'\n'就直接停止读取了。目前我的解决方案是在scanf下面增加一次getchar()，把stdin的'\n'先输出来。

### 5. 反转链表原来这么简单
习题3.12要求我们实现链表的反转，一开始我还以为有点麻烦，最后写完代码发现，原来反转链表的主要代码（循环体内的语句）只有4行，没想到这么简单！其实思路确实简单，就是保持原来的首节点不变，不断删除原首节点的下一节点并在表头插入。（以下代码省略了指针判空处理）
```
    struct list *prev = head->next;
    struct list *cur = prev->next;

    while (NULL != cur)
    {
        prev->next = cur->next; 
        cur->next = head->next;
        head->next = cur;
        cur = prev->next;
    }
```

### 4. 如何更高效地计算2^4000
习题3.9要求我们写一个整数算术运算包，并计算2^4000次方中含有0~9各位数字的数目。我用链表实现了整数的加法和乘法，然后使用简单的循环来实现幂运算:
```
for (cur_expo = 1; cur_expo < expo; cur_expo++)
{
    result = multiply_polynomials(first_poly, poly, &product_poly);
    if (SUCCESS != result)
    {
        printf("failed to multiply polynomial!\n");
        return result;
    }

    list_clear(first_poly);
    first_poly = product_poly;
    product_poly = NULL;
}
```
在运行时，计算2的1000次方花费大约十几秒，计算2的4000次方则电脑卡住超过半小时。于是我开始考虑采取性能更好的算法。我当时的直觉是不断的平方，那么很快就能算到4000次方了。沿着这个方向想下去，还真让我想到一个简单而性能更好的算法：
```
1. 将4000化成二进制形式(1111,1010,0000)，即4000 = 2^11 + 2^10 + 2^9 + 2^8 + 2^7 + 2^5
2. 创建数组a[k]（0<=k<12），令a[k]=2^(2^k)，显然a[k+1] = a[k]^2，所以通过12次循环即可计算出a[k]各项的值。
3. 2^4000 = a[11] + a[10] + a[9] + a[8] + a[7] + a[5]
```
编写代码实现这个算法后，编译运行，计算2的10000次方耗时不到1秒！说明时间性能得到明显改善。这道题让我感受到了算法的力量！

![](http://images2017.cnblogs.com/blog/866895/201710/866895-20171026031213473-594823117.png)

### 3. Bug 2：重复释放链表的内存
解决习题3.13时，在实现基数排序时，自己定义了两个链表数组，每次循环结束后把数组2拷贝到数组1，后面释放内存时分别对两个数组进行释放，结果由于重复释放内存导致系统崩溃！

### 2. 链表删除结点的注意事项
1. 处理好待删结点的前驱和后继的赋值
2. 注意头结点的赋值是否需要更改

### 1. Bug 1：自定义函数名与系统预留函数名冲突
写完习题3.9的代码后运行，每当我输入非法值时，总是提示"Segmentation fault (core dumped)"。大意是访问了非法内存。检查代码，已经进行了入参检查，没看出问题。使用gdb调试，发现每次运行到异常分支"error(...);"就抛出上述错误提示。error()是我用来输出错误提示信息的一个函数，其实现只是对printf的简单封装，应该没啥问题。最后，我使用printf代替error，结果就正常了。因此，估计error是C语言系统或编译器预留的一个函数，我自己重新定义这个函数后，实际上链接的时候还是链接到系统或编译器的那个函数去了，而那个函数的入参与我自定义的应该不一致，最后导致非法内存访问问题。

