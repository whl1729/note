## 入门

### 位于第一行的#!

* 当一个文件开头的两个字符为#!时，内核会扫描该行其余的部分，看是否存在可用来执行程序的解释器的完整路径。

* 中间如果出现任何空白符号都会略过。

* 内核还会扫描是否有一个选项要传递给解释器。内核会以被指定的选项来引用解释器，再搭配命令行的其他部分。

### 命令与参数


* 命令行由命令名和选项组成。

* 以空格键或Tab键隔开命令行中各个组成部分。

* 选项的开头是一个减号，后面接着一个字母。选项是可有可无的，有可能需要加上参数。不需要参数的选项可以合并。示例：`ls -l -t Documents`可以合并为`ls -lt Documents`。

* 分号(;)可用来分隔同一行里的多条命令。

* 命令行最后加上&符号，则shell将在后台执行此命令。

* 命令分类
    * 内建命令
    
    * shell命令

    * 外部命令

    > 1\. 建立一个新的进程。
    > 2\. 在新的进程里，在PATH变量所列出的目录中，寻找特定的命令。
    > 3\. 在新的进程里，以所找到的新程序取代执行中的shell程序并执行。

### 变量

* shell变量名的开头是字母或下划线，后面可接任意长度的字母、数字或下划线符号。变量名的长度无限制。

* shell变量可用来保存字符串值，所能保存的字符数也没有限制。

* 变量赋值的方式：先写变量名，紧接着等号(=)，最后是新值，中间完全没有任何空格。当所赋予的值含有空格时，请加上引号。示例：`school="Sun Yat-sen University"`。

* 在变量名前面加上$字符，可取出变量的值。

* 将一个变量赋值给另一个变量时，不需要使用双引号，但是使用双引号也没关系。不过，当你将几个变量连接起来时，就需要使用引号了。示例：`fullname="$first $second $third"`。

### 输出

* echo

    * 语法
    
    参数之间以一个空格隔开，并以换行符号结束。即：`echo [str1 str2 ...]`

    * 转义字符
    
    echo会解释每个字符串里的转义字符。

    * -n选项
    
    echo看到第一个参数为-n时，会忽略结尾的换行符。

* printf
    
    * 语法
    
    和C语言重点printf()函数类似，即：`printf format-string [arguments ..]`

### I/O重定向

* 标准输入/输出

    * 概念

    程序应该有数据的来源端、数据的目的端以及报告问题的地方，它们分别被成为标准输入、标准输出以及标准错误输出。

    * 默认的标准输入/输出

    当登录Unix时，默认的标准输入、输出及错误输出会被设置为你的终端。I/O重定向就是通过与终端交互或在shell脚本中设置，重新设置从哪里输入或输出到哪里。

* 重定向语法

    * 以<改变标准输入

    `program < file`可将program的标准输入修改为file。

    * 以>改变标准输出

    `program > file`可将program的标准输出修改为file。

    * 以>>附加到文件

    `program >> file`可将program的标准输出附加到file的结尾处。

    * 以|建立管道

    `program1 | program`可将program1的标准输出修改为program2的标准输入。

* 特殊文件
    
    * /dev/null
    
    传送到/dev/null的数据都会被系统丢掉，而读取/dev/null则会立即返回文件结束符号。

    * /dev/tty

    当程序打开该文件时，Unix会自动将它重定向到一个终端再与程序结合。这在程序必须读取人工输入时特别有用。示例：

    ```
    printf "Enter your password: "
    stty -echo    # 关闭自动打印输入字符的功能
    read pass1 < /dev/tty
    printf "Enter again: "
    read pass2 < /dev/tty
    stty echo    # 打开自动打印输入字符的功能
    ```

### 简单的执行跟踪

* `set -x`
    
打开跟踪功能。这会使得Shell显示每个被执行到的命令，并在前面加上"+ "。

* `set +x`

关闭跟踪功能。

## 查找与替换



