# 《针对云数据分析的弹性内存管理》阅读笔记

## 摘要

### 主要内容
1. 针对共享集群数据分析领域，提出一种自动的、弹性的内存管理方法：ElasticMem。
2. 该方法由以下几部分组成：
    * 动态修改Java虚拟机的内存限制的技术
    * 内存使用与垃圾回收预测建模
    * 在应用之间动态重分配内存的调度算法
3. 该方法相对静态内存分配的优点：
    * 内存紧缺时的查询失败率更低
    * 垃圾回收代价降低80%
    * 内存充足时的查询时间减少30%

### 疑问
1. 什么是共享集群（shared clusters）？

## 一、介绍

### 主要内容

#### 背景

1. 大型数据集分析需要依赖大数据系统，而大数据系统在非共享的集群上运行。
2. 共享集群需要资源管理器来分配资源，现代资源管理器通过容器来实现。
3. 本文主要关注内存分配问题。
4. 基于容器的调度算法在内存管理上存在局限：难以估计数据分析应用所需的内存。
5. 对应用所需的内存估计不准确会降低查询性能。
6. 在自动内存管理中引入垃圾回收机制，有时会降低查询任务执行速度。

#### 本文的创新点
1. 本文提出一种方法，数据分析任务被分配到不同的容器执行，而资源管理器弹性调整分配给这些容器的内存。最优化目标是将所有应用的失败率和执行时间降到最低。
2. 弹性管理容器内存是一个困难的问题：
    * 大多数系统不支持弹性内存分配
    * 需要理解额外内存如何避免失败和提高速率，需要对垃圾回收机制进行建模
    * 需要一个在多种数据分析应用中进行内存分配的算法
3. 本文主要关注JVM的内存分配。
4. 本文的贡献
    * 展示如何修改JVM以支持应用的堆内存的动态修改（见3.1节）
    * 提供在数据分析系统的多个应用中弹性管理内存的算法（见3.2节）
    * 使用机器学习算法来预测关系查询的堆状态和垃圾收集开支，以及内存是否耗尽

## 二、自动内存管理的性能影响

### 主要内容
1. 垃圾收集机制对查询性能有很大影响。
2. 目前JVM的垃圾收集大部分使用了分代收集算法。

## 三、弹性内存分配

### 第一节、JVM堆内存动态调整实现
1. OpenJDK内存管理方法
    * 用户在运行进程前先申请所需的堆内存最大值，然后JVM向操作系统申请相应内存，并划分新生代和老年代
    * 程序运行过程中申请内存时，如果剩余内存空间不够用，JVM会触发垃圾收集器去释放内存。如果垃圾回收后仍然不够，则抛出OutOfMemory错误。
    * 在JVM的生命期内堆内存最大值维持不变。

2. 修改OpenJDK源码以支持动态修改堆空间内存限制
    * 将堆内存最大值设置得足够大
    * 为JVM的新生代和老年代增加动态大小限制
    * 增加一个基于套接字的API，以提供堆状态查询、内存限制调整和垃圾收集触发等功能
    * 去使能JVM内部垃圾收集策略，而使用我们自己的内存管理器来控制何时使用何种垃圾收集器
    * 修改垃圾收集器的实现为总是释放回收后的内存给操作系统
    * 如果在当前内存限制下无法获取更多需要的内存，则暂停JVM，直至可以获取所需内存

### 第二节、动态内存分配
1. ElasticMem的主要部分是一个内存管理器
     * 同时监控查询运行状态和改变JVM的内存使用状况（通过触发垃圾手机或杀死JVM）
     * 每个动作对应一个度量值，而目标是所有动作的度量值的最大化。
     * 度量值由几个因素决定：是否会杀死JVM、是否暂停JVM、内存获取效率（耗费时间/内存空间）

2. 内存管理器根据两部分信息来做决策
    * JVM堆状态
    * 对JVM执行某个动作的度量值

