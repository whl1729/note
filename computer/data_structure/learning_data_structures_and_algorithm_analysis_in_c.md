# 《Data Structures and Algorithm Analysis in C》学习笔记

## 反思

### 最大子数组问题
书中给出了最大子数组问题的四种解法，时间复杂度分别是O(N^3), O(N^2), O(NlogN)和O(N)。

* O(N^3)解法。穷尽法。用下标组合(i, j)来表示第i到j个元素组成的子数组，遍历所有的子数组(i,j)，并计算出其元素之和，对比得最大值。
* O(N^2)解法。思路仍然是穷尽法。但对O(N^3)解法进行优化。O(N^3)解法包含太多重复性的工作，比如在计算子数组元素之和时，计算(i, j+1)时会重新计算一遍(i, j)，O(N^2)算法相当于把(i, j)的计算结果记录下来，计算(i, j+1)时就可以使用这个现成的计算结果。
* O(NlogN)解法。分治法。这种解法的思路时把大问题分解成两个相对小一些的问题，分别计算两个小问题的结果，然后汇总得到大问题的答案。把大数组均分成两个小数组，那么最大子数组必然位于左边、右边或中间这三个位置之一。
* O(N)解法。O(N)解法抓住了问题的本质：最大子数组从首元素到任意一个元素之间的总和永远大于0。根据这个性质，O(N)解法只需从左到右扫描一遍数组，扫描时，先假设当前扫描元素就是最大子数组的元素，并即时计算当前数组元素之和。等到计算结果不大于0后，可以舍弃当前子数组，从下一个元素开始重复统计。我认为O(N)解法比O(NlogN)解法更优的主要原因是前者更抓住了问题的本质。

### 链表的接口设计问题
在设计链表接口时，遇到几个问题：
1. 考虑可复用性，该如何定义链表节点的数据类型？
2. 链表节点的数据类型是否需要定义为指针类型？
3. 链表的push，insert等接口应该传入数据类型的指针还是链表类型的指针？
4. 如何设计返回值？输出参数应该放进函数参数列表中还是通过返回值返回？

#### 问题1：考虑可复用性，该如何定义链表节点的数据类型？

* 方案1：在定义链表节点时直接写死数据类型
```
struct Node
{
    int *element；  /* 数据类型固定为int * */
    struct Node *next;
};

typedef struct Node *List;

List list_push(List list, int *element);
```

评价：
这种方案最简单，但可复用性最差。如果换了一种节点类型。那么所有用到节点类型的地方都得修改。

* 方案2：在定义链表节点时不定义数据类型，在使用链表接口时再指定数据类型
```
struct Node
{
    ElementType *element;  /* 这里ElementType为未知类型，在使用链表接口再指定 */
    struct Node *next;
};

typedef struct Node *List;

List list_push(List list, ElementType *element);
```

评价：
这种方案可复用性还不错，但在使用时要注意头文件包含顺序，定义数据类型的头文件必须放在list.h前面，否则会编译不过。

* 方案3：在定义链表节点是将数据类型定义为void *
```
struct Node
{
    void *element;  /* 数据类型定义为void * */
    struct Node *next;
}

typedef struct Node *List;

List list_push(List list, void *element);
```

评价：
可复用性也很好。不过在使用时估计要将数据类型显式强转为void *，否则有些编译器会有警告。

#### 问题二： 链表节点的数据类型是否需要定义为指针类型？

#### 问题三： 链表的push，insert等接口应该传入数据类型的指针还是链表类型的指针？

### 链表的实现问题
1. 链表的接口实现中需不需要检查入参？还是由调用者确保输入参数合法？

## 摘录

### 数学证明方法

1. 数学归纳法
2. 反证法

### 递归的基本规则

1. 基准情形。必须存在不需递归就能解决的基准情形。
2. 不断推进。递归调用必须朝着基准情形的方向不断推进。
3. 设计法则。假设所有的递归调用都能生效。
4. 合成效益法则。切勿在不同的递归调用中做重复性的工作。

